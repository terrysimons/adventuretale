#!/usr/bin/env python
# -*- coding: utf-8 -*-

import argparse
import collections
import configparser
import logging

from pygame import Rect
import pygame
import pygame.freetype
import pygame.gfxdraw
import pygame.locals

from ghettogames.color import WHITE, BLACKLUCENT
from ghettogames.engine import RootSprite, MouseSprite, BitmappySprite
from ghettogames.engine import RootScene, GameEngine, FontManager
from ghettogames.engine import JoystickManager
from ghettogames.engine import pixels_from_data, pixels_from_path
from ghettogames.engine import image_from_pixels
from ghettogames.engine import rgb_triplet_generator

log = logging.getLogger('game')
log.setLevel(logging.INFO)

ch = logging.StreamHandler()
ch.setLevel(logging.INFO)

log.addHandler(ch)

# Turn on sprite debugging
BitmappySprite.DEBUG = True

class MenuBar(BitmappySprite):
    def __init__(self, *args, **kwargs):
        self.background_color = (255, 255, 0)
        self.border_width = 2
        self.menu_items = {}
        self.menu_offset_x = self.border_width
        self.menu_offset_y = self.border_width
        self.all_sprites = pygame.sprite.LayeredDirty()
        super().__init__(*args, **kwargs)        

        pygame.draw.rect(self.image, (255, 255, 255), self.rect)
        pygame.draw.rect(self.image, (255, 255, 255), self.rect, self.border_width)

    def add_menu(self, menu):
        self.menu_items[menu.name] = menu
        menu.image.set_colorkey((255, 0, 255))
        menu.add(self.groups())
        menu.add(self.all_sprites)
        menu.rect.x += self.menu_offset_x
        menu.rect.y += self.menu_offset_y
        self.menu_offset_x += menu.rect.width
        log.info(f'Menu Items: {self.menu_items}')

    def add_menu_item(self, menu_item, menu):
        if menu is None:
            self.add_menu(menu=menu_item)
            log.info(f'Adding new menu {menu_item}.')
        else:
            log.info(f'Adding menu item {menu_item} to menu {menu}.')

        self.dirty = 1

    def update(self):        
        for menu_item_name, menu_item in self.menu_items.items():
            menu_item = self.menu_items[menu_item_name]
            self.image.blit(menu_item.image, (menu_item.rect.x, menu_item.rect.y))

    def add(self, *groups):
        super().add(*groups)

    def remove(self, *groups):
        super().remove(*groups)

    def on_left_mouse_button_down_event(self, event):
        # Figure out which item was clicked.
        mouse = MouseSprite(x=event.pos[0],y=event.pos[1] , width=1, height=1)

        collided_sprites = pygame.sprite.spritecollide(mouse, self.all_sprites, False)

        log.info(f'Collided Sprites: {[collided_sprite.name for collided_sprite in collided_sprites]}')

        #for menu_item_name, menu_item in self.menu_items.items():
        #    if
    
        

class MenuItem(BitmappySprite):
    def __init__(self, *args, **kwargs):
        self.background_color = (255, 255, 255)
        self.border_width = 1
        super().__init__(*args, **kwargs)

        self.name = kwargs.get('name', None)

        # Don't set a name for the icon.
        if self.name:
            self.text = TextSprite(background_color=self.background_color, text_color=(0, 0, 0), x=0, y=0, width=self.width, height=self.height, text=self.name)
            self.text.image.set_colorkey((255, 0, 255))
            self.image.blit(self.text.image, (0, 0))


    def update(self):
        log.info('Updated Menu Item')

    def add(self, *groups):
        super().add(*groups)
        log.info(f'Added {groups}')

    def remove(self, *groups):
        super().remove(*groups)

    def on_left_mouse_button_down_event(self, event):
        log.info(f'{self.name}')


class InputDialog(BitmappySprite):
    def __init__(self, *args, dialog_text='Would you like to do a thing?', confirm_text='Confirm', cancel_text='Cancel', **kwargs):
        self.name = None
        self.background_color = (0, 0, 0)
        self.border_width = 1
        self.width = kwargs.get('width')
        self.dialog_text_sprite = TextBoxSprite(name=dialog_text, width=self.width//2, height=20, border_width=0)
        self.dialog_text_sprite.text.text = dialog_text                
        self.confirm_button = ButtonSprite(name=confirm_text, x=0, y=0, width=75, height=20)
        self.cancel_button = ButtonSprite(name=cancel_text, x=0, y=0, width=75, height=20)
        self._dirty = 1
        super().__init__(*args, **kwargs)

        self.name = kwargs.get('name', 'Untitled')
        self.callbacks = kwargs.get('callbacks', None)
        self.rect = self.image.get_rect()

        self.cancel_button.rect.bottomright = self.rect.bottomright
        self.confirm_button.rect.right = self.cancel_button.rect.left

    @property
    def dirty(self):
        return self._dirty

    @dirty.setter
    def dirty(self, value):
        self._dirty = value
        self.dialog_text_sprite.dirty = value
        self.confirm_button.dirty = value
        self.cancel_button.dirty = value

    def update(self):
        self.dirty = 2
        # Draw the bounding box.
        #pygame.draw.rect(self.image, (128, 128, 128), Rect(0, 0, self.width, self.height), self.border_width)

        #self.dialog_text_sprite.text.rect.x = self.dialog_text_sprite.rect.x - 200
        self.dialog_text_sprite.rect.center = self.rect.center
        self.confirm_button.rect.bottomright = self.rect.bottomright
        self.confirm_button.rect.x -= 20
        self.confirm_button.rect.y -= 20
        self.cancel_button.rect.bottomright = self.confirm_button.rect.bottomleft
        self.cancel_button.rect.x -= 20

        self.cancel_button.dirty = 2
        self.confirm_button.dirty = 2

        #self.screen.blit(self.dialog_text_sprite.image,)
        #self.screen.blit(self.cancel_button.image, (self.cancel_button.rect.x, self.cancel_button.rect.y))
        #self.screen.blit(self.confirm_button.image, (self.confirm_button.rect.x, self.confirm_button.rect.y))

        # Draw the buttons
        # Draw the text input field

    def add(self, *groups):
        super().add(*groups)

        self.cancel_button.add(*groups)
        self.confirm_button.add(*groups)
        self.dialog_text_sprite.add(*groups)

    def remove(self, *groups):
        super().remove(*groups)

        self.cancel_button.remove(*groups)
        self.confirm_button.remove(*groups)
        self.dialog_text_sprite.remove(*groups)
    
class TextBoxSprite(BitmappySprite):
    """
    """

    def __init__(self, *args, **kwargs):
        self.value = None
        self.text = None
        self.name = None
        self.background_color = (0, 0, 0)
        self.border_width = 1

        super().__init__(*args, **kwargs)

        self.name = kwargs.get('name', 'Untitled')
        self.background_color = (0, 0, 0)

        self.callbacks = kwargs.get('callbacks', None)

        self.rect = self.image.get_rect()

        self.text = TextSprite(background_color=self.background_color, x=0, y=0, width=self.width, height=self.height, text=self.value)

    def update(self):
        if self.text:
            self.text.rect.center = self.rect.center

            self.text.background_color = self.background_color
            self.text.dirty = 1
            self.text.update()

            self.image.blit(self.text.image, (0, 0, self.width, self.height))

        if self.border_width:
            pygame.draw.rect(self.image, (128, 128, 128), Rect(0, 0, self.width, self.height), self.border_width)

    def on_left_mouse_button_down_event(self, event):
        self.dirty = 1
        self.background_color = (128, 128, 128)
        self.update()

    def on_left_mouse_button_up_event(self, event):
        self.dirty = 1
        self.background_color = (0, 0, 0)
        self.update()


class ColorWellSprite(BitmappySprite):
    def __init__(self, *args, **kwargs):
        self.name = kwargs.get('name', 'Untitled')
        self.red = 0
        self.green = 0
        self.blue = 0
        self._dirty = 1
        self.text_sprite = TextBoxSprite(name=str(self.active_color), width=100, height=20)
        self.text_sprite.border_width = 1
        super().__init__(*args, **kwargs)

    @property
    def dirty(self):
        return self._dirty
        
    @dirty.setter
    def dirty(self, value):
        self._dirty = value
        self.text_sprite.dirty = value

    @property
    def active_color(self):
        return (self.red, self.green, self.blue)

    @active_color.setter
    def active_color(self, active_color):
        self.red = active_color[0]
        self.green = active_color[1]
        self.blue = active_color[2]
        self.dirty = 1

    @property
    def hex_color(self):
        hex_str = '{:02X}'
        red, green, blue = self.active_color

        red = hex_str.format(red)
        green = hex_str.format(green)
        blue = hex_str.format(blue)
        
        return f'#{red}{green}{blue}'

    def update(self):
        self.text_sprite.rect.midleft = self.rect.midright        
        pygame.draw.rect(self.image, (128, 128, 128), Rect(0, 0, self.width, self.height), 1)
        pygame.draw.rect(self.image, self.active_color, Rect(1, 1, self.width - 2, self.height - 2))
        self.text_sprite.value = str(self.active_color)
        self.text_sprite.text.text = self.hex_color
        self.text_sprite.text.text_box.start_x = 5
        self.text_sprite.text.text_box.start_y = 6
        self.text_sprite.update()

        self.screen.blit(self.text_sprite.image, (self.text_sprite.rect.x, self.text_sprite.rect.y))

    def add(self, *groups):
        super().add(*groups)
        import pdb; pdb.set_trace()
        self.text_sprite.add(self.groups())

    def remove(self, *groups):
        super().add(*groups)
        self.text_sprite.remove(self.groups())

class ButtonSprite(BitmappySprite):
    """
    """

    def __init__(self, *args, **kwargs):
        self.text = None
        self.name = None
        self.background_color = (0, 0, 0)

        super().__init__(*args, **kwargs)

        self.name = kwargs.get('name', 'Untitled')
        self.background_color = (0, 0, 0)

        self.callbacks = kwargs.get('callbacks', None)

        self.rect = self.image.get_rect()
        self.rect.x = self.x
        self.rect.y = self.y

        self.text = TextSprite(background_color=self.background_color, x=0, y=0, width=self.width, height=self.height, text=self.name)

    def update(self):
        if self.text:
            self.text.rect.center = self.rect.center

            self.text.background_color = self.background_color
            self.text.update()

            self.image.blit(self.text.image, (0, 0, self.width, self.height))

        pygame.draw.rect(self.image, (128, 128, 128), Rect(0, 0, self.width, self.height), 1)

    def on_left_mouse_button_down_event(self, event):
        self.dirty = 1
        self.background_color = (128, 128, 128)
        self.update()
        super().on_left_mouse_button_down_event(event)

    def on_left_mouse_button_up_event(self, event):
        self.dirty = 1
        self.background_color = (0, 0, 0)
        self.update()
        super().on_left_mouse_button_up_event(event)      

class CheckboxSprite(ButtonSprite):
    """
    """

    def __init__(self, *args, **kwargs):
        self.checked = False
        self.color = (128, 128, 128)

        super().__init__(*args, **kwargs)

    def update(self):
        if not self.checked:
            self.image.fill((0, 0, 0))

        pygame.draw.rect(self.image, self.color, Rect(0, 0, self.width, self.height), 1)

        if self.checked:
            pygame.draw.line(self.image, self.color, (0, 0), (self.width - 1, self.height - 1), 1)
            pygame.draw.line(self.image, self.color, (0, self.height - 1), (self.width - 1, 0), 1)

        self.rect.x = self.x
        self.rect.y = self.y

    def on_left_mouse_button_down_event(self, event):
        pass

    def on_left_mouse_button_up_event(self, event):
        self.dirty = 1
        self.checked = not self.checked
        self.update()



class ScrollBarSprite(BitmappySprite):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

    def update(self):
        pass

class ResizeWidgetSprite(BitmappySprite):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

    def update(self):
        self.dirty = 1
        self.image.fill((255, 255, 255))

    def on_left_mouse_button_down_event(self, event):
        pass

class CanvasSprite(BitmappySprite):
    WIDTH = 32
    HEIGHT = 32
    DEBUG = False
    
    def __init__(self, *args, has_mini_view=True, **kwargs):
        self.character_sprite = False
        self.color = (128, 128, 128)
        #self.grid_color = (255, 255, 0)

        self.border_thickness = 0
        self.border_margin = 0
        self.pixels_across = CanvasSprite.WIDTH
        self.pixels_tall = CanvasSprite.HEIGHT
        self.pixels = [(255, 0, 255)] * self.pixels_across * self.pixels_tall
        self.grid_line_width = 0
        self.pixel_boxes = []
        self.pixel_width = 1
        self.pixel_height = 1
        self.has_mini_view = has_mini_view
        self.mini_view = None
        self.resize_widget = None
        self.active_color = (255, 255, 255)
        self.dirty = 1

        class MiniView(CanvasSprite):
            def __init__(self, *args, border_thickness=0, pixels=None, **kwargs):
                self.pixels = pixels
                self.dirty_pixels = [False] * len(self.pixels)

                super().__init__(*args, has_mini_view=False, **kwargs)

                self.name = "Mini View" 
                
                if self.pixels_across < 64:
                    self.pixel_width = 64 // self.pixels_tall
                else:
                    self.pixel_width = 1
                    
                if self.pixels_tall < 64:
                    self.pixel_height = 64 // self.pixels_across
                else:
                    self.pixel_height = 1

                self.width = self.pixels_across * self.pixel_width
                self.height = self.pixels_tall * self.pixel_height
                
                self.border_thickness = 0
                self.border_margin = 0

                self.grid_line_width = 0

                self.image = pygame.Surface((self.width, self.height))
                self.rect = self.image.get_rect()
                self.rect.x = kwargs.get('x', 0)
                self.rect.y = kwargs.get('y', 0)
                self.rect.width = self.width
                self.rect.height = self.height

                self.color_palette = [(0, 255, 0), (255, 0, 255), (255, 255, 0), (0, 0, 0)]
                self.palette_index = 0
                #self.image.set_colorkey(self.color_palette[self.palette_index])
                self.image.fill(self.color_palette[self.palette_index])

                self.dirty_pixels = [True] * len(self.pixels)
                self.dirty = 1

            def update(self):
                x = 0
                y = 0

                for i, pixel in enumerate(self.pixels):
                    if self.dirty_pixels[i]:
                        if pixel == (255, 0, 255):
                            pygame.draw.rect(self.image, self.color_palette[self.palette_index], ((x, y), (self.pixel_width, self.pixel_height)))
                        else:
                            pygame.draw.rect(self.image, pixel, ((x, y), (self.pixel_width, self.pixel_height)))
                            #print(f'Updated pixel {i}')

                        self.dirty_pixels[i] = False                            

                    if (x + self.pixel_width) % (self.pixels_across * self.pixel_width) == 0:
                        x = 0
                        y += self.pixel_height
                    else:
                        x += self.pixel_width
                        
                self.screen.blit(self.image, (self.rect.x, self.rect.y))

            def on_left_mouse_button_up_event(self, event):
                self.palette_index += 1
                
                if self.palette_index >= len(self.color_palette):
                    self.palette_index = 0

                print(f'Palette {self.palette_index}: {self.color_palette[self.palette_index]}')

                self.image.fill(self.color_palette[self.palette_index])
                #self.image.set_colorkey(self.color_palette[self.palette_index])                

                self.dirty_pixels = [True] * len(self.pixels)

                self.dirty = 1

            def on_left_mouse_button_down_event(self, event):
                self.image.fill((255, 255, 255))
                #self.image.set_colorkey(self.color_palette[self.palette_index])                

                self.dirty_pixels = [True] * len(self.pixels)

                self.dirty = 1
                self.update()

            def __str__(self):
                return f'pixels across: {self.pixels_across}, pixels tall: {self.pixels_tall}, width: {self.width}, height: {self.height}, pixel width: {self.pixel_width}, pixel_height: {self.pixel_height}, pixels: {len(self.pixels)}, rect: {self.rect}'

        class BitmapPixelSprite(BitmappySprite):
            """
            """
            PIXEL_CACHE = {}

            def __init__(self, *args, border_thickness=1, **kwargs):
                self.name = kwargs.get('name')
                self.pixel_number = kwargs.get('pixel_number')
                self.pixel_width = kwargs.get('width', 1)
                self.pixel_height = kwargs.get('height', 1)
                self.border_thickness = 1
                self.width = self.pixel_width
                self.height = self.pixel_height
                self.color = (96, 96, 96)
                self.pixel_color = (0, 0, 0)
                
                super().__init__(self, *args, width=self.width, height=self.height)

                self.rect = pygame.Rect(0, 0, self.width, self.height)
                self.rect = pygame.draw.rect(self.image, self.color, (0, 0, self.width, self.height), 0)

                self.dirty = 1

            def update(self):
                cached_image = BitmapPixelSprite.PIXEL_CACHE.get(self.pixel_color)

                if not cached_image:
                    self.image = pygame.Surface((self.width, self.height))
                    pygame.draw.rect(self.image, self.pixel_color, (0, 0, self.width, self.height))
                
                    # Store this as an image and blit for a speedup.
                    if self.border_thickness:
                        pygame.draw.rect(self.image, self.color, (0, 0, self.width, self.height), self.border_thickness)

                    BitmapPixelSprite.PIXEL_CACHE[self.pixel_color] = self.image
                else:
                    self.image = cached_image

            def on_pixel_update_event(self, event):
                callback = None
                
                if self.callbacks:
                    callback = self.callbacks.get('on_pixel_update_event', None)

                if callback:
                    callback(event=event, trigger=self)
                #else:
                #    log.debug(f'{type(self)}: Pixel Update Event: {event} @ {self} (Pixel Number: {self.pixel_number}')

            def on_right_mouse_button_down_event(self, event):
                log.info(f'Right Mouse Button: {event}')

            def on_left_mouse_button_down_event(self, event):
                self.dirty = 1
                self.on_pixel_update_event(event)
                self.update()

            def on_mouse_drag_down_event(self, event, trigger):
                # There's not a good way to pass any useful info, so for now, pass None
                # since we're not using the event for anything in this class.
                self.on_left_mouse_button_down_event(None)

        super().__init__(*args, **kwargs)

        print(f'Canvas: {self.rect.x}, {self.rect.y}')        

        self.name = 'Bitmap Canvas'

        if self.pixels_across >= self.pixels_tall:
            self.pixel_width = self.width//self.pixels_across - self.border_thickness * 2
            self.pixel_height = self.width//self.pixels_across - self.border_thickness * 2
        else:
            self.pixel_width = self.height//self.pixels_tall - self.border_thickness * 2
            self.pixel_height = self.height//self.pixels_tall - self.border_thickness * 2            
        print(f'Pixels Across: {self.pixels_across}')
        print(f'Pixels Tall: {self.pixels_tall}')
        print(f'')

        self.all_sprites = pygame.sprite.LayeredDirty()

        self.pixel_boxes = [BitmapPixelSprite(name=f'pixel {i}',
                                              pixel_number=i,
                                              x=0,
                                              y=0,
                                              height=self.pixel_width,
                                              width=self.pixel_height)
                                              for i in range(self.pixels_across * self.pixels_tall)]
        
        for i in range(self.pixels_across * self.pixels_tall):
            self.pixel_boxes[i].pixel_color = self.pixels[i]
            self.pixel_boxes[i].add(self.all_sprites)

            # This allows us to update the mini map.
            self.pixel_boxes[i].callbacks = {'on_pixel_update_event': self.on_pixel_update_event}

            # This draws the map box.
            self.pixel_boxes[i].dirty = 1
            self.pixel_boxes[i].update()

        if self.has_mini_view:
            self.mini_view = MiniView(pixels=self.pixels, width=self.pixels_across, height=self.pixels_tall)
            self.mini_view.pixels = self.pixels
            self.mini_view.rect.x = self.screen_width - self.mini_view.width
            self.mini_view.rect.y = self.rect.y

        # Do some cleanup
        # For some reason we have a double grid border, so let's wipe out the canvas.
        #self.dirty = 1                        
        #self.image.fill((255, 255, 0), rect=self.rect)

        self.update_anyway = True
        self.dirty = 1
        self.update()

    def on_pixel_update_event(self, event, trigger):
        if self.mini_view:
            self.mini_view.pixels[trigger.pixel_number] = trigger.pixel_color

            # Note: Shouldn't we
            self.mini_view.dirty_pixels[trigger.pixel_number] = True
            self.mini_view.on_pixel_update_event(event, trigger)
            self.mini_view.dirty = 1
            self.mini_view.update()

        if not self.update_anyway and self.pixel_boxes[trigger.pixel_number].pixel_color == trigger.pixel_color:
        #    # This prevents us from updating the pixel if it's already the same color.
        #    log.info('pass')
            pass
        else:
            print(f'Pixel Update: {event}, {trigger} Pixel Number: {trigger.pixel_number}, {self.pixel_boxes[trigger.pixel_number].pixel_color} -> {trigger.pixel_color}')            
            self.pixel_boxes[trigger.pixel_number].pixel_color = trigger.pixel_color            
            self.pixel_boxes[trigger.pixel_number].dirty = 1
            self.pixel_boxes[trigger.pixel_number].update()
            self.dirty = 1
            self.update()

    def update(self):        
        if self.mini_view is None:
            # This means that we're in a mini view, which itself doesn't contain a mini view.
            self.draw_pixels()
        else:
            self.draw_grid()
            self.draw_pixels()

            self.mini_view.dirty = 1
            self.mini_view.update()
            self.update_anyway = False            

    def add(self, *groups):
        super().add(*groups)
        
        if self.mini_view is not None:
            self.mini_view.add(*groups)

    def remove(self, *groups):
        super().remove(*groups)

        if self.mini_view is not None:
            self.mini_view.remove(*groups)

    def draw_pixels(self):
        [pixel_box.update() for pixel_box in self.pixel_boxes]

    def draw_grid(self):
        # Note: We should do this instead.
        # self.grid.update()
        
        x = 0
        y = 0
        self.border_thickness = 0
        self.border_margin = 0
        for i, pixel_box in enumerate(self.pixel_boxes):
            pixel_x = x * pixel_box.pixel_width
            pixel_y = y * pixel_box.pixel_height
            #pixel_x = self.border_margin + self.border_thickness + (x * pixel_box.pixel_width) + (x * pixel_box.border_thickness)
            #pixel_y = self.border_margin + self.border_thickness + (y * pixel_box.pixel_height) + (y * pixel_box.border_thickness)

            # Note: We might be able to do this up above, and make this method super efficient.
            pixel_box.rect.x = pixel_x + self.rect.x
            pixel_box.rect.y = pixel_y + self.rect.y

            #log.info(f'x: {self.rect.x}, y: {self.rect.y}')

            self.image.blit(pixel_box.image, (pixel_x, pixel_y))

            if (x + 1) % self.pixels_across == 0:
                x = 0
                y += 1
            else:
                x += 1

    def on_left_mouse_button_down_event(self, event):
        # Check for a sprite collision against the mouse pointer.
        #
        # First, we need to create a pygame Sprite that represents the tip of the mouse.
        mouse = MouseSprite(x=event.pos[0],y=event.pos[1] , width=1, height=1)

        # MTS: This
        collided_sprites = pygame.sprite.spritecollide(mouse, self.all_sprites, False)

        #print(f'collided sprites: {collided_sprites}')

        for sprite in collided_sprites:
            sprite.pixel_color = self.active_color
            sprite.on_left_mouse_button_down_event(event)

        #print(f'Mouse @ {mouse.rect}')
        self.dirty = 1
        self.update()

    #def on_right_mouse_button_down_event(self, event):
    #    log.info(f'Right Mouse Down: {event}')

    #def on_right_mouse_button_up_event(self, event):
    #    log.info(f'Right Mouse Up: {event}')

    def on_mouse_drag_down_event(self, event, trigger):
        # TODO: Mask out right and left.
        self.on_left_mouse_button_down_event(event)

    def on_new_file_event(self, event, trigger):        
        for i, pixel in enumerate([(255, 0, 255)] * self.pixels_across * self.pixels_tall):
            event = pygame.event.Event(GameEngine.GAMEEVENT, {'action':'on_load_file_event',
                                                              'pixel_color': pixel,
                                                              'pixel_number': i})

            # Create a pixel update event for the mini map.
            self.on_pixel_update_event(event=event, trigger=event)

        self.dirty = 1
        self.update()

    def on_save_file_event(self, event, trigger):
        pixels = []
        
        for pixel_box in self.pixel_boxes:
            pixels.append(pixel_box.pixel_color)

        # Generate a new bitmappy sprite and tell it to save.
        save_sprite = BitmappySprite(width=self.pixels_across,
                                     height=self.pixels_tall,
                                     name='Tiley McTile Face')

        save_sprite.image = image_from_pixels(pixels=pixels,
                                              width=save_sprite.width,
                                              height=save_sprite.height)

        save_sprite.save(filename='savefile.cfg')

        #self.save(filename='screenshot.cfg')
            

    def on_load_file_event(self, event, trigger):
        load_sprite = BitmappySprite(filename='savefile.cfg',
                                     width=self.pixels_across,
                                     height=self.pixels_tall)

        pixel_data = pygame.image.tostring(load_sprite.image, 'RGB')

        pixels = pixels_from_data(pixel_data=pixel_data)

        print(pixels)

        # Update the canvas' pixels across and tall
        self.pixels_across = load_sprite.width
        self.pixels_tall = load_sprite.height

        #pixels = [pixel_box.pixel_color for pixel_box in self.pixel_boxes]
        #pixels = [(255, 255, 255)] * len(pixels)

        #print(pixels)

        for i, pixel in enumerate(pixels):
            trigger.pixel_number = i
            trigger.pixel_color = (255, 255, 255)

            event = pygame.event.Event(GameEngine.GAMEEVENT, {'action':'on_load_file_event',
                                                              'pixel_color': pixel,
                                                              'pixel_number': i})

            # Create a pixel update event for the mini map.
            self.on_pixel_update_event(event=event, trigger=event)

        #for pixel_box in self.pixel_boxes:
        #    pixel_box.dirty = 1
        #    pixel_box.update()

        self.dirty = 1
        self.update()

class TextSprite(RootSprite):
    def __init__(self, *args, background_color=BLACKLUCENT, text_color=WHITE, alpha=0, text='Text', **kwargs):
        self.background_color = background_color
        self.text_color = text_color
        self.alpha = 0
        self.text = text
        self.font_manager = FontManager(self)
        self.joystick_manager = JoystickManager(self)
        self.joystick_count = len(self.joystick_manager.joysticks)

        class TextBox(object):
            def __init__(self, font_controller, x, y, line_height=15, text='Text', text_color=WHITE):
                self.image = None
                self.rect = None
                self.start_x = x
                self.start_y = y
                self.line_height = line_height
                self.text_color = text_color

                super().__init__()


                pygame.freetype.set_default_resolution(font_controller.font_dpi)
                self.font = pygame.freetype.SysFont(name=font_controller.font,
                                                    size=font_controller.font_size)

            def print(self, surface, string):
                (self.image, self.rect) = self.font.render(string, self.text_color)
                
                #pygame.draw.rect(self.image, (255, 255, 0), self.rect, 0)

                surface.blit(self.image, (self.x, self.y))
                self.rect.x = self.x
                self.rect.y = self.y
                self.y += self.line_height

            def reset(self):
                self.x = self.start_x
                self.y = self.start_y

            def indent(self):
                self.x += 10

            def unindent(self):
                self.x -= 10

        self.text_box = TextBox(font_controller=self.font_manager, x=0, y=0, text=self.text, text_color=self.text_color)

        super().__init__(*args, **kwargs)

        self.text_box.start_x = self.rect.centerx - 10
        self.text_box.start_y = self.rect.centery - 5


        self.background_color = background_color
        self.alpha = alpha

        if not alpha:
            #self.image.set_colorkey(self.background_color)
            self.image.convert()
        else:
            # Enabling set_alpha() and also setting a color
            # key will let you hide the background
            # but things that are blited otherwise will
            # be translucent.  This can be an easy
            # hack to get a translucent image which
            # does not have a border, but it causes issues
            # with edge-bleed.
            #
            # What if we blitted the translucent background
            # to the screen, then copied it and used the copy
            # to write the text on top of when translucency
            # is set?  That would allow us to also control
            # whether the text is opaque or translucent, and
            # it would also allow a different translucency level
            # on the text than the window.
            self.image.convert_alpha()
            self.image.set_alpha(self.alpha)

        self.rect = self.image.get_rect()
        self.rect.x += self.x
        self.rect.y += self.y

        

        self.update()

    def update(self):
        self.dirty = 2
        self.image.fill(self.background_color)

        self.text_box.reset()
        self.text_box.print(self.image, f'{self.text}')

class SliderSprite(BitmappySprite):
    def __init__(self, *args, **kwargs):
        self.name = kwargs.get('name', 'Untitled')                
        self.height = kwargs.get('height')
        self.width = kwargs.get('width')
        self.x = kwargs.get('x')
        self.y = kwargs.get('y')
        self.text_sprite = TextBoxSprite(name=str((0, 0, 0)), width=40, height=20)
        self.text_sprite.border_width = 1

        self.width = self.width + 20
        self.height = self.height


        class SliderKnobSprite(BitmappySprite):
            def __init__(self, *args, **kwargs):
                self.name = kwargs.get('name', 'Untitled')
                self.value = 0

                super().__init__(*args, **kwargs)
                
                self.image.fill((0, 0, 0))

                self.rect = Rect(1, 1, self.width - 2, self.height - 2)

                self.update()

            def update(self):
                pygame.draw.rect(self.image, (127, 127, 127), self.rect)
                #pygame.draw_rect(self.image, (0, 0, 0))

            def on_left_mouse_button_down_event(self, event):
                self.dirty = 1
                self.value = event.pos[0]

                # Hack            
                if self.value > 255:
                    self.value = 255
                elif self.value < 0:
                    self.value = 0
                
                self.rect.x = self.value
                self.update()
                super().on_left_mouse_button_down_event(event)

            def on_mouse_drag_down_event(self, event, trigger):
                # There's not a good way to pass any useful info, so for now, pass None
                # since we're not using the event for anything in this class.
                self.on_left_mouse_button_down_event(event)

        self.slider_knob = SliderKnobSprite(name=self.name, width=self.height*2, height=self.height*4)

        super().__init__(height=self.height, width=self.width, x=self.x, y=self.y)

        self.name = kwargs.get('name', 'Untitled')        

        # This is the stuff pygame really cares about.
        self.image = pygame.Surface((self.width, self.height))
        self.background = pygame.Surface((self.width, self.height))
        self.image.fill((255,255,255))
        self.rect = self.image.get_rect()

        #self.image.blit(self.text.image, (0, 0))
        self.rect.x = self.x
        self.rect.y = self.y
        #self.text.start_x = 0
        #self.text.start_y = 0

        #self.all_sprites = pygame.sprite.LayeredDirty((self.slider_knob))

    @property
    def value(self):
        return self.slider_knob.value

    @value.setter
    def value(self, value):
        log.info('SLIDER')
        self.slider_knob.value = value

    def update(self):
        #pygame.draw.rect(self.image, (255, 0, 0), Rect(self.rect.centerx, self.rect.centery, self.rect.width, self.rect.height), 1)
        self.text_sprite.rect.midleft = self.rect.midright
        self.text_sprite.rect.x -= 10
        self.text_sprite.value = self.slider_knob.value
        self.text_sprite.text.text = self.slider_knob.value
        self.text_sprite.update()

        self.image.fill((0, 0, 0))

        color = (255, 255, 255)
        
        for i in range(256):
            color = (i, i, i)
            
            if self.name == 'R':
                color = (i, 0, 0)
            elif self.name == 'G':
                color = (0, i, 0)
            elif self.name == 'B':
                color = (0, 0, i)
                
            pygame.draw.line(self.image,
                             color,
                             (i, self.height//2 - 1),
                             (i, self.height//2), 1)
                
            pygame.draw.line(self.image,
                             color,
                             (i, self.height//2),
                             (i, self.height//2), 1)
                
            pygame.draw.line(self.image,
                             color,
                             (i,
                              self.height//2 + 1),
                             (i, self.height//2), 1)

        # Draw the knob
        self.image.blit(self.slider_knob.image, (self.slider_knob.value, self.rect.height//4))
        super().update()


    def on_left_mouse_button_down_event(self, event):
        self.dirty = 1

        log.debug('Calling Slider Knob Callback')
        self.slider_knob.on_left_mouse_button_down_event(event)
        self.update()
        super().on_left_mouse_button_down_event(event)

    def on_mouse_drag_down_event(self, event, trigger):
        self.dirty = 1
        self.on_left_mouse_button_down_event(event)
        # There's not a good way to pass any useful info, so for now, pass None
        # since we're not using the event for anything in this class.
        #self.slider_knob.on_mouse_drag_down_event(event, trigger)
        #self.update()
        #super().on_mouse_drag_down_event(event)        
        

class LabeledSliderSprite(SliderSprite):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

class LoadDialogScene(RootScene):
    def __init__(self, previous_scene):
        super().__init__()
        self.screen = pygame.display.get_surface()
        self.screen_width = self.screen.get_width()
        self.screen_height = self.screen.get_height()
        self.previous_scene = previous_scene
        self.screenshot = pygame.Surface((self.screen_width, self.screen_height))
        self.screenshot.blit(self.screen, (0, 0))

        self.all_sprites = pygame.sprite.LayeredDirty()
        
        self.load_dialog = InputDialog(name='Load Sprite', dialog_text='Would you like to load a sprite?', confirm_text='Load', x=0, y=0, width=self.screen_width//2, height=self.screen_height//2)
        self.load_dialog.rect.center = self.screen.get_rect().center

        self.load_dialog.cancel_button.callbacks = {'on_left_mouse_button_up_event': self.on_cancel_event}
        self.load_dialog.confirm_button.callbacks = {'on_left_mouse_button_up_event': self.on_confirm_event}

        self.load_dialog.add(self.all_sprites)

    def dismiss(self):
        self.load_dialog.remove(self.all_sprites)
        self.next = self.previous_scene
        self.previous_scene.next = self.previous_scene
        self.screen.blit(self.screenshot, (0, 0))
        self.previous_scene.dirty = 1
        self.previous_scene.update()

    def on_cancel_event(self, event, trigger):
        log.info(f'Cancel: event: {event}, trigger: {trigger}')
        self.dismiss()

        
    def on_confirm_event(self, event, trigger):
        log.info(f'Load File: event: {event}, trigger: {trigger}')
        self.previous_scene.canvas_sprite.on_load_file_event(event, trigger)
        self.dismiss()

class SaveDialogScene(RootScene):
    def __init__(self, previous_scene):
        super().__init__()
        self.screen = pygame.display.get_surface()
        self.screen_width = self.screen.get_width()
        self.screen_height = self.screen.get_height()
        self.previous_scene = previous_scene
        self.screenshot = pygame.Surface((self.screen_width, self.screen_height))
        self.screenshot.blit(self.screen, (0, 0))        

        self.all_sprites = pygame.sprite.LayeredDirty()
        
        self.save_dialog = InputDialog(name='Save Sprite', dialog_text='Would you like to save your sprite?', confirm_text='Save', x=0, y=0, width=self.screen_width//2, height=self.screen_height//2)
        self.save_dialog.rect.center = self.screen.get_rect().center

        self.save_dialog.cancel_button.callbacks = {'on_left_mouse_button_up_event': self.on_cancel_event}
        self.save_dialog.confirm_button.callbacks = {'on_left_mouse_button_up_event': self.on_confirm_event}

        self.save_dialog.add(self.all_sprites)

    def dismiss(self):
        self.save_dialog.remove(self.all_sprites)
        self.next = self.previous_scene
        self.previous_scene.next = self.previous_scene
        self.screen.blit(self.screenshot, (0, 0))        
        self.previous_scene.dirty = 1
        self.previous_scene.update()        

    def on_cancel_event(self, event, trigger):
        log.info(f'Cancel: event: {event}, trigger: {trigger}')
        self.dismiss()

    def on_confirm_event(self, event, trigger):
        log.info(f'Safe File: event: {event}, trigger: {trigger}')
        self.previous_scene.canvas_sprite.on_save_file_event(event, trigger)
        self.dismiss()

class BitmapEditorScene(RootScene):
    def __init__(self):
        super().__init__()
        self.screen = pygame.display.get_surface()
        self.screen_width = self.screen.get_width()
        self.screen_height = self.screen.get_height()
        self.button_width = 75

        self.all_sprites = pygame.sprite.LayeredDirty()

        #self.scroll_bar_sprite = ScrollBarSprite(name='File List', x=0, y=0, width=20, height=300)

        self.menu_bar_sprite = MenuBar(name='Menu Bar', x=0, y=0, width=self.screen_width, height=20)

        log.info('Rect is: %s' % self.menu_bar_sprite.rect)
        log.info('Rect bottom: %s' % self.menu_bar_sprite.rect.bottom)

        self.menu_icon = MenuItem(name=None, filename='raspberry.cfg', x=0, y=0, width=16, height=16)
        # When we load the sprite, we set a name.
        self.menu_icon.name = None
        self.file_menu = MenuItem(name='File', width=32, height=16)
        self.edit_menu = MenuItem(name='Edit', width=32, height=16)        

        #print(self.menu_icon)

        # Add the menu icon as a root level menu item.
        self.menu_bar_sprite.add_menu_item(menu_item=self.menu_icon, menu=None)
        self.menu_bar_sprite.add_menu_item(menu_item=self.file_menu, menu=None)
        self.menu_bar_sprite.add_menu_item(menu_item=self.edit_menu, menu=None)

        # We'll use the top left quartile of the screen to draw the canvas.
        # We want a square canvas, so we'll use the height as our input.
        self.canvas_sprite = CanvasSprite(name='Bitmap Canvas', x=0, y=self.menu_bar_sprite.rect.bottom + 10, width=int(self.screen_height * 0.75), height=int(self.screen_height * 0.75))
        self.canvas_sprite.add(self.all_sprites)
        
        #self.new_button_sprite = ButtonSprite(name='New', x=self.screen_width - self.button_width, y=219, width=self.button_width, height=20)
        #self.new_button_sprite.callbacks = {'on_left_mouse_button_up_event': self.on_new_file_event}

        self.save_button_sprite = ButtonSprite(name='Save', x=self.screen_width - self.button_width, y=249, width=self.button_width, height=20)

        self.save_button_sprite.callbacks = {'on_left_mouse_button_up_event': self.on_save_dialog_event}

        self.load_button_sprite = ButtonSprite(name='Load', x=self.screen_width - self.button_width, y=279, width=self.button_width, height=20)

        self.load_button_sprite.callbacks = {'on_left_mouse_button_up_event': self.on_load_dialog_event}

        self.quit_button_sprite = ButtonSprite(name='Quit', x=self.screen_width - self.button_width, y=309, width=self.button_width, height=20)

        self.quit_button_sprite.callbacks = {'on_left_mouse_button_up_event': self.on_quit_event}

        self.red_slider_sprite = LabeledSliderSprite(name='R', x=0, y=self.screen_height - 70, width=256, height=10)

        self.red_slider_sprite.callbacks = {'on_left_mouse_button_down_event': self.on_slider_event}

        self.green_slider_sprite = LabeledSliderSprite(name='G', x=0, y=self.screen_height - 50, width=256, height=10)

        self.green_slider_sprite.callbacks = {'on_left_mouse_button_down_event': self.on_slider_event}

        self.blue_slider_sprite = LabeledSliderSprite(name='B', x=0, y=self.screen_height - 30, width=256, height=10)

        self.blue_slider_sprite.callbacks = {'on_left_mouse_button_down_event': self.on_slider_event}

        self.color_well_sprite = ColorWellSprite(name='Colorwell', x=0, y=0, width=64, height=64)

        self.color_well_sprite.rect.midleft = self.green_slider_sprite.rect.midright
        self.color_well_sprite.rect.x += 30

        self.red = self.red_slider_sprite.value
        self.green = self.green_slider_sprite.value
        self.blue = self.blue_slider_sprite.value

        self.canvas_sprite.active_color = (self.red, self.green, self.blue)


        # Change this?
        #self.all_sprites.add(self.new_button_sprite)
        self.all_sprites.add(self.save_button_sprite)
        self.all_sprites.add(self.load_button_sprite)
        self.all_sprites.add(self.quit_button_sprite)
        self.all_sprites.add(self.red_slider_sprite)
        self.all_sprites.add(self.red_slider_sprite.text_sprite)
        self.all_sprites.add(self.blue_slider_sprite)
        self.all_sprites.add(self.blue_slider_sprite.text_sprite)
        self.all_sprites.add(self.green_slider_sprite)
        self.all_sprites.add(self.green_slider_sprite.text_sprite)
        self.all_sprites.add(self.color_well_sprite)
        self.all_sprites.add(self.color_well_sprite.text_sprite)
        self.all_sprites.add(self.menu_bar_sprite)        

        self.all_sprites.clear(self.screen, self.background)

    def update(self):
        super().update()

    def render(self, screen):
        super().render(screen)

    def switch_to_scene(self, next_scene):
        super().switch_to_scene(next_scene)

    def on_new_file_event(self, event, trigger):
        log.info(f'New File: event: {event}, trigger: {trigger}')
        self.canvas_sprite.on_new_file_event(event, trigger)

    def on_load_dialog_event(self, event, trigger):
        self.next = LoadDialogScene(previous_scene=self)

    def on_save_dialog_event(self, event, trigger):
        self.next = SaveDialogScene(previous_scene=self)

    def on_slider_event(self, event, trigger):
        value = trigger.value

        log.info(f'Slider: event: {event}, trigger: {trigger} value: {value}')                    

        if value < 0:
            value = 0
            trigger.value = 0
        elif value > 255:
            value = 255
            trigger.value = 255
        
        if trigger.name == 'R':
            self.red = value

            self.red_slider_sprite.slider_knob.value = value
            self.red_slider_sprite.dirty = 1
            self.red_slider_sprite.update()
            self.red_slider_sprite.text_sprite.dirty = 1
            self.red_slider_sprite.text_sprite.update()            
        elif trigger.name == 'G':
            self.green = value

            self.green_slider_sprite.slider_knob.value = value            
            self.green_slider_sprite.dirty = 1
            self.green_slider_sprite.update()        
            self.green_slider_sprite.text_sprite.dirty = 1
            self.green_slider_sprite.text_sprite.update()            
        elif trigger.name == 'B':
            self.blue = value

            self.blue_slider_sprite.slider_knob.value = value            
            self.blue_slider_sprite.dirty = 1
            self.blue_slider_sprite.update()        
            self.blue_slider_sprite.text_sprite.dirty = 1
            self.blue_slider_sprite.text_sprite.update()                            

            
        #else:


        self.canvas_sprite.active_color = (self.red, self.green, self.blue)
        self.canvas_sprite.dirty = 2
        self.canvas_sprite.update()

        self.color_well_sprite.active_color = (self.red, self.green, self.blue)
        self.color_well_sprite.dirty = 1
        self.color_well_sprite.update()


    def on_key_up_event(self, event):
        # 1-8 selects Sprite Frame
        # Spacebar
        # Escape quits
        # c cycles through color boxes
        # r swap recent colors
        # n new bitmap
        # l load bitmap
        # s save bitmap
        pass

    def on_key_down_event(self, event):
        pass

    def on_right_mouse_button_down_event(self, event):
        log.info('Right Down')

    def on_right_mouse_button_up_event(self, event):
        log.info('Right Up')
        # If we're on the edge of an outside pixel, ignore
        # the right click so we don't crash.
        try:
            red, green, blue, alpha = self.screen.get_at(event.pos)
            log.info(f'Red: {red}, Green: {green}, Blue: {blue}, Alpha: {alpha}')

            # TODO: Make this a proper type.
            trigger = pygame.event.Event(0, {'name': 'R', 'value': red})
            self.on_slider_event(event=event, trigger=trigger)

            trigger = pygame.event.Event(0, {'name': 'G', 'value': green})
            self.on_slider_event(event=event, trigger=trigger)

            trigger = pygame.event.Event(0, {'name': 'B', 'value': blue})
            self.on_slider_event(event=event, trigger=trigger)

            self.dirty = 1
        except IndexError:
            pass
        

   # def on_left_mouse_button_down_event(self, event):
        # Check for a sprite collision against the mouse pointer.
        #
        # First, we need to create a pygame Sprite that represents the tip of the mouse.
   #     mouse = MouseSprite(x=event.pos[0],y=event.pos[1] , width=1, height=1)

   #     collided_sprites = pygame.sprite.spritecollide(mouse, self.all_sprites, False)

   #     for sprite in collided_sprites:
   #         sprite.on_left_mouse_button_down_event(event)

        #print(f'Mouse @ {mouse.rect}')

    #def on_left_mouse_button_up_event(self, event):
        # Check for a sprite collision against the mouse pointer.
        #
        # First, we need to create a pygame Sprite that represents the tip of the mouse.
    #    mouse = MouseSprite(x=event.pos[0],y=event.pos[1] , width=1, height=1)

    #    collided_sprites = pygame.sprite.spritecollide(mouse, self.all_sprites, False)

    #    for sprite in collided_sprites:
    #        sprite.on_left_mouse_button_up_event(event)

        #print(f'Mouse @ {mouse.rect}')

    #def on_mouse_drag_down_event(self, event, trigger):
        # Check for a sprite collision against the mouse pointer.
        #
        # First, we need to create a pygame Sprite that represents the tip of the mouse.

        #print(f'Mouse Drag @ {mouse.rect}')

        #def on_mouse_drag_up_event(self, event):
        # Check for a sprite collision against the mouse pointer.
        #
        # First, we need to create a pygame Sprite that represents the tip of the mouse.

        #print(f'Mouse Drag @ {mouse.rect}')

class Game(GameEngine):
    # Set your game name/version here.
    NAME = "Bitmappy"
    VERSION = "1.0"

    def __init__(self, options):
        super().__init__(options=options)
        self.load_resources()

        width, height = options.get('size').split('x')

        # Convert to integers
        CanvasSprite.WIDTH = int(width)
        CanvasSprite.HEIGHT = int(height)

        #self.register_game_event('save', self.on_save_event)
        #self.register_game_event('load', self.on_load_event)

    @classmethod
    def args(cls, parser):
        # Initialize the game engine's options first.
        # This ensures that our game's specific options
        # are listed last.
        parser = GameEngine.args(parser)

        group = parser.add_argument_group('Game Options')

        group.add_argument('-v', '--version',
                           action='store_true',
                           help='print the game version and exit')
        group.add_argument('-s', '--size',
                           default='32x32')
        
        return parser

    def start(self):
        # Call the main game engine's start routine to initialize
        # the screen and set the self.screen_width, self.screen_height variables
        # and do a few other init related things.
        super().start()

        # Note: Due to the way things are wired, you must set self.active_scene after
        # calling super().start() in this method.
        self.clock = pygame.time.Clock()
        self.active_scene = BitmapEditorScene()

        while self.active_scene != None:
            self.process_events()

            self.active_scene.update()

            self.active_scene.render(self.screen)

            self.clock.tick(self.fps)

            if self.update_type == 'update':
                pygame.display.update(self.active_scene.rects)
            elif self.update_type == 'flip':
                pygame.display.flip()                    

            self.active_scene = self.active_scene.next

    def on_key_up_event(self, event):
        self.active_scene.on_key_up_event(event)

        # Process normal key events like q/ESCAPE for quit via engine.
        super().on_key_up_event(event)

        # KEYUP            key, mod
        #if event.key == pygame.K_q:
        #    log.info(f'User requested quit.')
        #    event = pygame.event.Event(pygame.QUIT, {})
        #    pygame.event.post(event)

    # This will catch calls which our scene engine doesn't yet implement.
    def __getattr__(self, attr):
        try:
            if self.active_scene:
                return getattr(self.active_scene, attr)
            else:
                raise Exception(f'Scene not activated in call to {attr}()')
        except AttributeError:
            raise AttributeError(f'{attr} is not implemented in Game {type(self)} or active scene {type(self.active_scene)}.')

def main():
    parser = argparse.ArgumentParser(f"{Game.NAME} version {Game.VERSION}")

    # args is a class method, which allows us to call it before initializing a game
    # object, which allows us to query all of the game engine objects for their
    # command line parameters.
    parser = Game.args(parser)
    args = parser.parse_args()
    game = Game(options=vars(args))
    game.start()

if __name__ == '__main__':
    try:
        main()
    except Exception as e:
        raise e
    finally:
        pygame.quit()


