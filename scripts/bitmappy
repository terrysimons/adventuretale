#!/usr/bin/env python3
from __future__ import annotations
import logging
import os
import time

from pygame import Rect
import pygame
import pygame.freetype
import pygame.gfxdraw
import pygame.locals

<<<<<<< Updated upstream
from glitchygames.engine import GameEngine
from glitchygames.events.mouse import MousePointer
=======
from glitchygames.engine import GameEngine, ASSET_PATH
>>>>>>> Stashed changes
from glitchygames import events
from glitchygames.pixels import pixels_from_data
from glitchygames.pixels import image_from_pixels
from glitchygames.scenes import Scene
from glitchygames.sprites import BitmappySprite
from glitchygames.ui import SliderSprite, ColorWellSprite, InputDialog, MenuBar, MenuItem

LOG: logging.Logger = logging.getLogger('game')
LOG.setLevel(logging.INFO)

# Turn on sprite debugging
BitmappySprite.DEBUG = True


class InputConfirmationDialogScene(Scene):
    log: logging.Logger = LOG
    NAME: Literal['InputConfirmationDialog'] = 'InputConfirmationDialog'
    DIALOG_TEXT: Literal['Would you like to do a thing?'] = 'Would you like to do a thing?'
    CONFIRMATION_TEXT: Literal['Confirm'] = 'Confirm'
    CANCEL_TEXT: Literal['Cancel'] = 'Cancel'
    VERSION: Literal[''] = ''

    def __init__(self, previous_scene, options=None, groups=pygame.sprite.LayeredDirty()):
        super().__init__(options=options, groups=groups)
        self.previous_scene = previous_scene

        self.dialog: InputDialog = InputDialog(
            name=self.NAME,
            dialog_text=self.DIALOG_TEXT,
            confirm_text=self.CONFIRMATION_TEXT,
            pos=(self.screen.get_rect().center[0] // 2, self.screen.get_rect().center[1] // 2),
            size=(self.screen_width // 2, self.screen_height // 2),
            parent=self,
            groups=self.all_sprites
        )

    def setup(self) -> None:
        self.dialog.cancel_button.callbacks = {'on_left_mouse_button_up_event': self.on_cancel_event}
        self.dialog.confirm_button.callbacks = {'on_left_mouse_button_up_event': self.on_confirm_event}

        self.dialog.add(self.all_sprites)

    def cleanup(self) -> None:
        self.next_scene = self

    def dismiss(self) -> None:
        self.previous_scene.next_scene = self.previous_scene
        self.next_scene = self.previous_scene

    def on_cancel_event(self, event, trigger) -> None:
        self.log.info(f'Cancel: event: {event}, trigger: {trigger}')
        self.dismiss()

    def on_confirm_event(self, event, trigger) -> None:
        self.log.info(f'{type(self)}on_confirm_event: event: {event}, trigger: {trigger}')
        self.dismiss()

    def on_input_box_submit_event(self, control) -> None:
        self.log.info(f'{self.name} Got text input from: {control.name}: {control.text}')

    def on_mouse_button_up_event(self, event) -> None:
        self.dialog.input_box.activate()

    def on_key_up_event(self, event) -> None:
        if self.dialog.input_box.active:
            self.dialog.on_key_up_event(event)
        else:
            if event.key == pygame.K_TAB:
                self.dialog.input_box.activate()
            else:
                super().on_key_up_event(event)

    def on_key_down_event(self, event) -> None:
        if self.dialog.input_box.active:
            self.dialog.on_key_down_event(event)
        else:
            super().on_key_up_event(event)

class NewCanvasDialogScene(InputConfirmationDialogScene):
    log: logging.Logger = LOG
    NAME: str = 'New Canvas'
    DIALOG_TEXT: str = 'Are you sure you want to clear the canvas?'
    CONFIRMATION_TEXT: str = 'Clear'
    CANCEL_TEXT: str = 'Cancel'

    def __init__(self, previous_scene, options=None, groups=pygame.sprite.LayeredDirty()) -> None:
       super().__init__(previous_scene, options=options, groups=pygame.sprite.LayeredDirty())

    def on_confirm_event(self, event, trigger) -> None:
        self.log.info(f'New Canvas: event: {event}, trigger: {trigger}')
        self.previous_scene.canvas.on_load_file_event(
            self.dialog.input_box,
            self.dialog.input_box
        )
        self.dismiss()

class LoadDialogScene(InputConfirmationDialogScene):
    log: logging.Logger = LOG
    NAME: str = 'Load Sprite'
    DIALOG_TEXT: str = 'Would you like to load a sprite?'
    CONFIRMATION_TEXT: str = 'Load'
    CANCEL_TEXT: str = 'Cancel'
    VERSION: str = ''

    def __init__(self, previous_scene, options=None, groups=pygame.sprite.LayeredDirty()) -> None:
       super().__init__(previous_scene, options=options, groups=pygame.sprite.LayeredDirty())

    def on_confirm_event(self, event, trigger) -> None:
        self.log.info(f'Load File: event: {event}, trigger: {trigger}')
        self.previous_scene.canvas.on_load_file_event(
            self.dialog.input_box,
            self.dialog.input_box
        )
        self.dismiss()


class SaveDialogScene(InputConfirmationDialogScene):
    log: logging.Logger = LOG
    NAME: str = "Save Sprite"
    DIALOG_TEXT: str = 'Would you like to save your sprite?'
    CONFIRMATION_TEXT: str = 'Save'
    CANCEL_TEXT: str = 'Cancel'
    VERSION: str = ''

    def __init__(self, previous_scene, options=None, groups=pygame.sprite.LayeredDirty()):
       super().__init__(previous_scene, options=options, groups=pygame.sprite.LayeredDirty())

    def on_confirm_event(self, event, trigger):
        self.log.info(f'Save File: event: {event}, trigger: {trigger}')
        self.previous_scene.canvas.on_save_file_event(
            self.dialog.input_box,
            self.dialog.input_box
        )
        self.dismiss()

class BitmapPixelSprite(BitmappySprite):
    """
    """
    log: logging.Logger = LOG
    PIXEL_CACHE = {}

    def __init__(self, pos=(0, 0), size=(1, 1), color=(255, 255, 0), name=None, pixel_number=0, border_thickness=1, groups=pygame.sprite.LayeredDirty()):
        super().__init__(pos=pos, size=size, name=name, groups=groups)
        self.log.debug(f'BITMAP PIXEL SPRITE GROUPS: {groups}')
        self.pixel_number: int = pixel_number
        self.pixel_width: int = size[0]
        self.pixel_height: int = size[1]
        self.border_thickness: int = border_thickness
        self.width = self.pixel_width
        self.height = self.pixel_height
        self.color: tuple[Literal[96], Literal[96], Literal[96]] = (96, 96, 96)
        self.pixel_color = color

        self.rect = pygame.draw.rect(self.image, self.color, (self.x, self.y, self.width, self.height), self.border_thickness)

    @property
    def pixel_color(self) -> pygame.Color:
        return self._pixel_color

    @pixel_color.setter
    def pixel_color(self, new_pixel_color) -> None:
        self._pixel_color = new_pixel_color
        self.dirty = 1

    def update(self) -> None:
        self.log.debug(f'Updating Pixel #: {self.pixel_number} @ {self.x}, {self.y}')
        cached_image = BitmapPixelSprite.PIXEL_CACHE.get(self.pixel_color)

        if not cached_image:
            self.image = pygame.Surface((self.width, self.height))
            self.rect = pygame.draw.rect(self.image, self.pixel_color, (0, 0, self.width, self.height))

            # Store this as an image and blit for a speedup.
            if self.border_thickness:
                pygame.draw.rect(self.image, self.color, (0, 0, self.width, self.height), self.border_thickness)

            BitmapPixelSprite.PIXEL_CACHE[self.pixel_color] = self.image
        else:
            self.image = cached_image


    def on_pixel_update_event(self, event) -> None:
        if self.callbacks:
            callback = self.callbacks.get('on_pixel_update_event', None)

            if callback:
                callback(event=event, trigger=self)


    def on_left_mouse_button_down_event(self, event) -> None:
        self.dirty = 1
        self.on_pixel_update_event(event)

    # def on_left_mouse_drag_event(self, event, trigger):
    #     # There's not a good way to pass any useful info, so for now, pass None
    #     # since we're not using the event for anything in this class.
    #     self.on_left_mouse_button_down_event(None)

class CanvasSprite(BitmappySprite):
    log: logging.Logger = LOG
    WIDTH: int = 32
    HEIGHT: int = 32
    DEBUG: bool = False

    def __init__(self, pos, size, name, has_mini_view=True, groups=pygame.sprite.LayeredDirty()):
        super().__init__(pos, size, name=name, groups=groups)

        self.character_sprite: bool = False

        self.border_thickness: int = 0
        self.border_margin: int = 0
        self.pixels_across: int = CanvasSprite.WIDTH
        self.pixels_tall: int = CanvasSprite.HEIGHT
        self.pixels = [(255, 0, 255)] * self.pixels_across * self.pixels_tall
        self.grid_line_width = 0
        self.pixel_boxes = []
        self.pixel_width = 1
        self.pixel_height = 1
        self.mini_view = None
        self.resize_widget = None
        self.active_color = (255, 255, 255)

        print(f'Canvas: {self.rect.x}, {self.rect.y}')

        self.name = 'Bitmap Canvas'

        # TODO(BUG): This smells. Might explain odd alignment issues with the last row.
        if self.pixels_across >= self.pixels_tall:
            self.pixel_width: int = (self.width // self.pixels_across) - (self.border_thickness * 2)
            self.pixel_height: int = (self.width // self.pixels_across) - (self.border_thickness * 2)
        else:
            self.pixel_width = (self.height // self.pixels_tall) - (self.border_thickness * 2)
            self.pixel_height = (self.height // self.pixels_tall) - (self.border_thickness * 2)

        print(f'Pixels Across: {self.pixels_across}')
        print(f'Pixels Tall: {self.pixels_tall}')
        print(f'')

        # Can we change this to groups?
        self.all_sprites = groups

        self.pixel_boxes = [
                BitmapPixelSprite(
                    name=f'pixel {pixel_number}',
                    pos=(self.rect.x * i, self.rect.y * i),
                    groups=groups
                )
            for i, pixel_number in enumerate(range(1))
        ]

        for pixel_number, pixel in enumerate(self.pixel_boxes):
            self.log.info(
                f'BRO: Pixel Number: {pixel_number} '
                f'x: {pixel.x} '
                f'y: {pixel.y} '
                f'rect.x: {pixel.rect.x} '
                f'rect.y: {pixel.rect.y}'
            )

        self.all_sprites.add(self)

        pixel_offset_x = 0
        pixel_offset_y = 0
        for pixel_number in range(self.pixels_across * self.pixels_tall):
            pixel_x = pixel_offset_x * self.pixel_width
            pixel_y = pixel_offset_y * self.pixel_height
            self.log.info(f'Pixel box #: {pixel_number}')
            pixel_box = BitmapPixelSprite(
                name=f'pixel {pixel_number}',
                pos=pos,
                size=(self.pixel_width, self.pixel_height),
                groups=groups
            )
            pixel_box.pixel_color = self.pixels[pixel_number]
            pixel_box.rect.x = pixel_x + self.rect.x
            pixel_box.rect.y = pixel_y + self.rect.y

            # This allows us to update the mini map.
            pixel_box.callbacks = {'on_pixel_update_event': self.on_pixel_update_event}

            self.pixel_boxes.append(pixel_box)

            if (pixel_offset_x + 1) % self.pixels_across == 0:
                pixel_offset_x = 0
                pixel_offset_y += 1
            else:
                pixel_offset_x += 1

        self.pixel_boxes = [
            BitmapPixelSprite(name=f'pixel {i}',
                              pixel_number=i,
                              pos=(0, 0),
                              size=(self.pixel_width, self.pixel_height))
            for i in range(self.pixels_across * self.pixels_tall)
        ]

        for pixel_box in self.pixel_boxes:
           self.log.info(f'Pixel Box Groups: {pixel_box.groups}')
           self.all_sprites.add(pixel_box)

        for i in range(self.pixels_across * self.pixels_tall):
            self.pixel_boxes[i].pixel_color = self.pixels[i]
            self.pixel_boxes[i].add(self.all_sprites)

            # This allows us to update the mini map.
            self.pixel_boxes[i].callbacks = {'on_pixel_update_event': self.on_pixel_update_event}

            # This draws the map box.
            self.pixel_boxes[i].dirty = 1

        if has_mini_view:
            pixel_width, pixel_height = MiniView.pixels_per_pixel(self.pixels_across, self.pixels_tall)
            self.mini_view = MiniView(pixels=self.pixels,
                                      pos=(
                                        self.screen_width - (self.pixels_across * pixel_width),
                                        self.rect.y + self.pixels_tall
                                      ),
                                      size=(
                                        self.pixels_across,
                                        self.pixels_tall
                                      ),
                                      groups=groups)
            self.mini_view.pixels = self.pixels
            self.mini_view.rect.x = self.screen_width - self.mini_view.width
            self.mini_view.rect.y = self.rect.y

        self.update_anyway = False

    def on_pixel_update_event(self, event, trigger):
        if self.mini_view:
            self.mini_view.pixels[trigger.pixel_number] = trigger.pixel_color
            self.mini_view.dirty_pixels[trigger.pixel_number] = True
            self.mini_view.on_pixel_update_event(event, trigger)
            self.mini_view.dirty = 1

        self.pixel_boxes[trigger.pixel_number].pixel_color = trigger.pixel_color

        # if self.pixel_boxes[trigger.pixel_number].dirty:
        #     self.pixel_boxes[trigger.pixel_number].update()

        self.dirty = 1

    def update_nested_sprites(self):
        if self.mini_view:
            self.mini_view.dirty = self.dirty

    def update(self):
        pass
        x = 0
        y = 0
        self.border_thickness = 0
        self.border_margin = 0
        for i, pixel_box in enumerate(self.pixel_boxes):
            if pixel_box.dirty:
                pixel_x = x * pixel_box.pixel_width
                pixel_y = y * pixel_box.pixel_height

                adjusted_pixel_box_width = pixel_box.pixel_width if x == 0 else pixel_box.pixel_width - 1
                adjusted_pixel_box_height = pixel_box.pixel_height if y == 0 else pixel_box.pixel_height - 1

                pixel_x = self.border_margin + self.border_thickness + (x * adjusted_pixel_box_width) + (x * pixel_box.border_thickness)
                pixel_y = self.border_margin + self.border_thickness + (y * adjusted_pixel_box_height) + (y * pixel_box.border_thickness)

                pixel_box.rect.x = pixel_x + self.rect.x
                pixel_box.rect.y = pixel_y + self.rect.y
                self.image.blit(pixel_box.image, (pixel_box.x, pixel_box.y))

                if self.mini_view:
                    self.mini_view.dirty = 1

            if (x + 1) % self.pixels_across == 0:
                x = 0
                y += 1
            else:
                x += 1

    # def on_left_mouse_button_down_event(self, event):
    #     # Check for a sprite collision against the mouse pointer.
    #     #
    #     # First, we need to create a pygame Sprite that represents the tip of the mouse.
    #     mouse = MousePointer(pos=(event.pos[0], event.pos[1]))

    #     collided_sprites = pygame.sprite.spritecollide(mouse, self.all_sprites, False)

    #     for sprite in collided_sprites:
    #         sprite.pixel_color = self.active_color
    #         sprite.dirty = 1

    #         if type(sprite) == BitmapPixelSprite:
    #             self.on_pixel_update_event(event=event, trigger=sprite)
    #         elif sprite is not self:
    #             sprite.on_left_mouse_button_down_event(event)

    # def on_left_mouse_drag_event(self, event, trigger):
    #     self.on_left_mouse_button_down_event(event)

    # def on_new_file_event(self, event, trigger):
    #     for i, pixel in enumerate([(255, 0, 255)] * self.pixels_across * self.pixels_tall):
    #         event = pygame.event.Event(events.GAMEEVENT, {'action':'on_new_file_event',
    #                                                       'pixel_color': pixel,
    #                                                       'pixel_number': i})

    #         # Create a pixel update event for the mini map.
    #         self.on_pixel_update_event(event=event, trigger=event)

    #     self.dirty = 1
    #     # self.update()

    # def on_save_file_event(self, event, trigger):
    #     pixels = []

    #     for pixel_box in self.pixel_boxes:
    #         pixels.append(pixel_box.pixel_color)

    #     # Generate a new bitmappy sprite and tell it to save.
    #     save_sprite = BitmappySprite(x=0,
    #                                  y=0,
    #                                  width=self.pixels_across,
    #                                  height=self.pixels_tall,
    #                                  name='Tiley McTile Face')

    #     save_sprite.image = image_from_pixels(pixels=pixels,
    #                                           width=save_sprite.width,
    #                                           height=save_sprite.height)

    #     self.log.info(f'Saving file as: {event.text}')
    #     save_sprite.save(filename=event.text)

    #     self.dirty = 1

    #     #self.save(filename='screenshot.cfg')


    # def on_load_file_event(self, event, trigger):
    #     self.log.info(f'Loading file: {event.text}')

    #     load_sprite = BitmappySprite(
    #         filename=event.text,
    #         pos=(0, 0),
    #         size=(self.pixels_across, self.pixels_tall)
    #     )

    #     pixel_data = pygame.image.tostring(load_sprite.image, 'RGB')

    #     pixels = pixels_from_data(pixel_data=pixel_data)

    #     # self.log.info(pixels)

    #     # Update the canvas' pixels across and tall
    #     self.pixels_across = load_sprite.width
    #     self.pixels_tall = load_sprite.height

    #     # pixels = [pixel_box.pixel_color for pixel_box in self.pixel_boxes]
    #     # pixels = [(255, 255, 255)] * len(pixels)

    #     #print(pixels)

    #     for i, pixel in enumerate(pixels):
    #         trigger.pixel_number = i
    #         trigger.pixel_color = pixel

    #         event = pygame.event.Event(events.GAMEEVENT, {'action':'on_load_file_event',
    #                                                       'pixel_color': pixel,
    #                                                       'pixel_number': i})

    #         # Create a pixel update event for the mini map.
    #         self.on_pixel_update_event(event=event, trigger=event)

    #     # for pixel_box in self.pixel_boxes:
    #     #     pixel_box.dirty = 1
    #     #     pixel_box.update()

    #     self.dirty = 1
    #     # self.update()


class MiniView(CanvasSprite):
    log = LOG

    @staticmethod
    def pixels_per_pixel(pixels_across, pixels_tall):
        pixel_width = 0
        pixel_height = 0

        if pixels_across < 64:
            pixel_width = 64 // pixels_tall
        else:
            pixel_width = 1

        if pixels_tall < 64:
            pixel_height = 64 // pixels_tall
        else:
            pixel_height = 1

        return (pixel_width, pixel_height)

    def __init__(self, pos, size, name=None, border_thickness=0, pixels=None, groups=None):
        super().__init__(pos, size, name=name, has_mini_view=False, groups=groups)
        self.pixels = pixels
        self.dirty_pixels = [False] * len(self.pixels)

        self.pixel_width, self.pixel_height = self.pixels_per_pixel(self.pixels_across, self.pixels_tall)

        # if self.pixels_across < 64:
        #    self.pixel_width = 64 // self.pixels_tall
        # else:
        #    self.pixel_width = 1

        # if self.pixels_tall < 64:
        #    self.pixel_height = 64 // self.pixels_across
        # else:
        #    self.pixel_height = 1

        self.width = self.pixels_across * self.pixel_width
        self.height = self.pixels_tall * self.pixel_height

        self.border_thickness = 0
        self.border_margin = 0

        self.grid_line_width = 0

        self.image = pygame.Surface((self.width, self.height))
        self.rect = self.image.get_rect()
        # self.rect.x = x
        # self.rect.y = y
        # self.rect.width = self.width
        # self.rect.height = self.height

        self.color_palette = [(0, 255, 0), (255, 0, 255), (255, 255, 0), (0, 0, 0)]
        self.palette_index = 0
        self.image.fill(self.color_palette[self.palette_index])

        self.dirty_pixels = [True] * len(self.pixels)

    # Hack: Not sure why this is needed
    #
    # This is usually for sub-sprites that need to be updated when
    # their parent changes
    #
    # This defers the update of the mini map down in the scene manager
    #
    # The dirty pixel check here saves us a lot of FPS since it ensures
    # that we aren't updating the mini map every frame
    def update_nested_sprites(self):
        if any(self.dirty_pixels):
            self.dirty = 1
            self.dirty_pixels = [False] * len(self.pixels)

    def update(self):
        pass
        # x = 0
        # y = 0

        # for i, pixel in enumerate(self.pixels):
        #     if pixel == (255, 0, 255):
        #         pygame.draw.rect(self.image, self.color_palette[self.palette_index], ((x, y), (self.pixel_width, self.pixel_height)))
        #     else:
        #         pygame.draw.rect(self.image, pixel, ((x, y), (self.pixel_width, self.pixel_height)))
        #             # print(f'Updated pixel {i}')



        #     if (x + self.pixel_width) % (self.pixels_across * self.pixel_width) == 0:
        #         x = 0
        #         y += self.pixel_height
        #     else:
        #         x += self.pixel_width

        # if any(self.dirty_pixels):
        #     self.screen.blit(self.image, (self.rect.x, self.rect.y))

    def on_left_mouse_button_up_event(self, event):
        self.palette_index += 1

        if self.palette_index >= len(self.color_palette):
            self.palette_index = 0

        self.log.debug(f'MiniMap Palette {self.palette_index}: {self.color_palette[self.palette_index]}')

        self.image.fill(self.color_palette[self.palette_index])

        self.dirty_pixels = [True] * len(self.pixels)
        self.dirty = 1

    def __str__(self):
        return f'pixels across: {self.pixels_across}, pixels tall: {self.pixels_tall}, width: {self.width}, height: {self.height}, pixel width: {self.pixel_width}, pixel_height: {self.pixel_height}, pixels: {len(self.pixels)}, rect: {self.rect}'


class BitmapEditorScene(Scene):
    log = LOG
    icon: pygame.Surface = pygame.image.load(os.path.join(ASSET_PATH, 'bitmappy.png'))

    # Set your game name/version here.
    NAME = "Bitmappy"
    VERSION = "1.0"

    def __init__(self, options, groups=pygame.sprite.LayeredDirty()):
        super().__init__(options=options, groups=groups)

        width, height = options.get('size').split('x')
        CanvasSprite.WIDTH = int(width)
        CanvasSprite.HEIGHT = int(height)

        self.menu_bar = MenuBar(
            name='Menu Bar',
            pos=(0, 0),
            size=(self.screen_width, 20),
            groups=self.all_sprites
        )

        self.menu_icon = MenuItem(name=None,
                                  filename=os.path.join(ASSET_PATH, 'raspberry.cfg'),
                                  pos=(0, 0),
                                  size=(16, self.menu_bar.height)
                                  )
        # When we load the sprite, we set a name.
        self.menu_icon.name = None

        self.menu_bar.add_menu_item(menu_item=self.menu_icon,
                                    menu=None)

        self.new_menu_item = MenuItem(
            name='New',
            pos=(self.menu_icon.rect.topright[0], self.menu_icon.rect.y),
            size=(40, self.menu_bar.height),
            parent=self,
            groups=self.all_sprites
        )
        self.save_menu_item = MenuItem(
            name='Save',
            pos=(self.new_menu_item.rect.topright[0], self.new_menu_item.rect.y),
            size=(40, self.menu_bar.height),
            parent=self,
            groups=self.all_sprites
        )
        self.load_menu_item = MenuItem(
            name='Load',
            pos=(self.save_menu_item.rect.midright[0], self.save_menu_item.rect.y),
            size=(40, self.menu_bar.height),
            parent=self,
            groups=self.all_sprites
        )
        self.quit_menu_item = MenuItem(
            name='Quit',
            pos=(self.load_menu_item.rect.midright[0], self.load_menu_item.rect.y),
            size=(40, self.menu_bar.height),
            parent=self,
            groups=self.all_sprites
        )

        # self.file_menu = MenuItem(name='File', width=32, height=16, groups=self.all_sprites)
        # self.save_menu_item = MenuItem(name='Save', width=40, height=16, groups=self.all_sprites)
        # self.load_menu_item = MenuItem(name='Load', width=40, height=16, groups=self.all_sprites)
        # self.spacer_menu_item = MenuItem(name='----', width=40, height=16, groups=self.all_sprites)
        # self.quit_menu_item = MenuItem(name='Quit', width=40, height=16, groups=self.all_sprites)

        # self.edit_menu = MenuItem(name='Edit', width=32, height=16, groups=self.all_sprites)

        # Add the menu icon as a root level menu item.
        # self.menu_bar.add_menu_item(menu_item=self.menu_icon, menu=None)
        # self.menu_bar.add_menu_item(menu_item=self.file_menu, menu=None)
        # self.menu_bar.add_menu_item(menu_item=self.edit_menu, menu=None)

        # self.menu_bar.add_menu_item(menu_item=self.save_menu_item, menu=None)
        # self.menu_bar.add_menu_item(menu_item=self.load_menu_item, menu=None)
        # self.menu_bar.add_menu_item(menu_item=self.quit_menu_item, menu=None)
        # self.file_menu.add_menu_item(menu_item=self.save_menu_item, menu=None)
        # self.file_menu.add_menu_item(menu_item=self.load_menu_item, menu=None)
        # self.file_menu.add_menu_item(menu_item=self.spacer_menu_item, menu=None)
        # self.file_menu.add_menu_item(menu_item=self.quit_menu_item, menu=None)

        # We'll use the top left quartile of the screen to draw the canvas.
        # We want a square canvas, so we'll use the height as our input.
        # self.canvas = CanvasSprite(name='Bitmap Canvas', x=0, y=self.menu_bar.rect.bottom + 10, width=int(self.screen_height * 0.75), height=int(self.screen_height * 0.75), groups=self.all_sprites)
        # self.canvas = CanvasSprite(
        #     name='Bitmap Canvas',
        #     pos=(0, 32),
        #     size=(int(self.screen_height * 0.75), int(self.screen_height * 0.75)),
        #     groups=self.all_sprites
        # )

        # slider_height = 9

        # self.red_slider = SliderSprite(
        #     name='R',
        #     pos=(10, self.screen_height - 70),
        #     size=(256, slider_height),
        #     groups=self.all_sprites
        # )
        # self.red_slider.callbacks = {'on_left_mouse_button_down_event': self.on_slider_event}

        # self.green_slider = SliderSprite(
        #     name='G',
        #     pos=(10, self.screen_height - 50),
        #     size=(256, slider_height),
        #     groups=self.all_sprites
        # )
        # self.green_slider.callbacks = {'on_left_mouse_button_down_event': self.on_slider_event}

        # self.blue_slider = SliderSprite(
        #     name='B',
        #     pos=(10, self.screen_height - 30),
        #     size=(256, slider_height),
        #     groups=self.all_sprites
        # )
        # self.blue_slider.callbacks = {'on_left_mouse_button_down_event': self.on_slider_event}

        # self.red_slider.value = 0
        # self.blue_slider.value = 0
        # self.green_slider.value = 0

        # self.color_well = ColorWellSprite(
        #     name='Colorwell',
        #     pos=(self.red_slider.rect.midright[0] + 30, self.red_slider.rect.y),
        #     size=(64, 64),
        #     groups=groups
        # )

        # self.color_well.active_color = (
        #     self.red_slider.value,
        #     self.green_slider.value,
        #     self.blue_slider.value
        # )

        # self.canvas.active_color = self.color_well.active_color

        self.all_sprites.clear(self.screen, self.background)

        # TODO: Plumb this into the scene manager
        # self.register_game_event('save', self.on_save_event)
        # self.register_game_event('load', self.on_load_event)

        # self.new_canvas_dialog_scene = NewCanvasDialogScene(options=self.options, previous_scene=self)
        # self.load_dialog_scene = LoadDialogScene(options=self.options, previous_scene=self)
        # self.save_dialog_scene = SaveDialogScene(options=self.options, previous_scene=self)

        # These are set up in the GameEngine class.
        self.log.info(f'Game Options: {options}')

    def update(self):
        self.menu_bar.update()
        # self.canvas.update()

    def on_menu_item_event(self, event):
        self.log.info(f'Scene got menu item event: {event}')
        if not event.menu.name:
            # This is for the system menu.
            self.log.info('System Menu Clicked')
        else:
            if event.menu.name == 'New':
                self.on_new_canvas_dialog_event(event=event)
            elif event.menu.name == 'Save':
                self.on_save_dialog_event(event=event)
            elif event.menu_item.name == 'Load':
                self.on_load_dialog_event(event=event)
            elif event.menu.name == 'Quit':
                self.log.info('User quit from menu item.')
                self.scene_manager.quit()
            else:
                raise Exception(f'Unhandled Menu Item: {event}')
        self.dirty = 1

    # NB: Keepings this around causes GG-7 not to manifest... curious.
    # This function is extraneous now that on_new_canvas_dialog_event exists.
    #
    # There is also some dialog drawing goofiness when keeping this which
    # goes away when we remove it.
    #
    # Keeping as a workaround for GG-7 for now.
    def on_new_file_event(self, event):
        self.new_canvas_dialog_scene.all_sprites.clear(self.new_canvas_dialog_scene.screen, self.screenshot)
        self.canvas.on_new_file_event(event=event, trigger=event)
        self.dirty = 1

    def on_new_canvas_dialog_event(self, event):
        self.new_canvas_dialog_scene.all_sprites.clear(self.new_canvas_dialog_scene.screen, self.screenshot)
        self.next_scene = self.new_canvas_dialog_scene
        self.dirty = 1

    def on_load_dialog_event(self, event):
        self.load_dialog_scene.all_sprites.clear(self.load_dialog_scene.screen, self.screenshot)
        self.next_scene = self.load_dialog_scene
        self.dirty = 1

    def on_save_dialog_event(self, event):
        self.save_dialog_scene.all_sprites.clear(self.save_dialog_scene.screen, self.screenshot)
        self.next_scene = self.save_dialog_scene
        self.dirty = 1

    def on_color_well_event(self, event, trigger):
        self.log.info('COLOR WELL EVENT')

    def on_slider_event(self, event, trigger):
        value = trigger.value

        self.log.debug(f'Slider: event: {event}, trigger: {trigger} value: {value}')

        if value < 0:
            value = 0
            trigger.value = 0
        elif value > 255:
            value = 255
            trigger.value = 255

        if trigger.name == 'R':
            self.red_slider.value = value
        elif trigger.name == 'G':
            self.green_slider.value = value
        elif trigger.name == 'B':
            self.blue_slider.value = value

        self.color_well.active_color = (self.red_slider.value, self.green_slider.value, self.blue_slider.value)
        self.canvas.active_color = (self.red_slider.value, self.green_slider.value, self.blue_slider.value)

    def on_right_mouse_button_up_event(self, event):
        # If we're on the edge of an outside pixel, ignore
        # the right click so we don't crash.
        try:
            red, green, blue, alpha = self.screen.get_at(event.pos)
            self.log.info(f'Red: {red}, Green: {green}, Blue: {blue}, Alpha: {alpha}')

            # TODO: Make this a proper type.
            trigger = pygame.event.Event(0, {'name': 'R', 'value': red})
            self.on_slider_event(event=event, trigger=trigger)

            trigger = pygame.event.Event(0, {'name': 'G', 'value': green})
            self.on_slider_event(event=event, trigger=trigger)

            trigger = pygame.event.Event(0, {'name': 'B', 'value': blue})
            self.on_slider_event(event=event, trigger=trigger)
        except IndexError:
            pass

    def on_left_mouse_button_down_event(self, event):
        sprites = self.sprites_at_position(pos=event.pos)

        for sprite in sprites:
           sprite.on_left_mouse_button_down_event(event)

    def on_left_mouse_button_up_event(self, event):
        sprites = self.sprites_at_position(pos=event.pos)

        for sprite in sprites:
           sprite.on_left_mouse_button_up_event(event)

    def on_left_mouse_drag_event(self, event, trigger):
        self.canvas.on_left_mouse_drag_event(event, trigger)

        try:
            sprites = self.sprites_at_position(pos=event.pos)

            for sprite in sprites:
                sprite.on_left_mouse_drag_event(event, trigger)
        except AttributeError:
            pass


    @classmethod
    def args(cls, parser):
        parser.add_argument('-v', '--version',
                           action='store_true',
                           help='print the game version and exit')
        parser.add_argument('-s', '--size',
                           default='32x32')


def main():
<<<<<<< Updated upstream
    os.path.join(os.path.dirname( __file__ ), 'bitmappy.png')

    try:
        icon: pygame.Surface = pygame.image.load('bitmappy.png')
    except FileNotFoundError:
        icon = None

    GameEngine.icon = icon
    GameEngine(game=BitmapEditorScene, icon=icon).start()
=======
    GameEngine(game=BitmapEditorScene).start()
>>>>>>> Stashed changes


if __name__ == '__main__':
    main()





# Canvas Grid
# 8x8 would be 8 boxes:
# |1|2|3|4|5|6|7|8|
#
# So # boxes * width of boxes + # of boxes * width of grid + 1 * width of grid
#
#
# Create a rectangle:
#