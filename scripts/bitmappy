#!/usr/bin/env python
# -*- coding: utf-8 -*-
import logging

from pygame import Rect
import pygame
import pygame.freetype
import pygame.gfxdraw
import pygame.locals

from glitchygames.color import WHITE, BLACKLUCENT
from glitchygames.engine import GameEngine
from glitchygames import events
from glitchygames.pixels import pixels_from_data, pixels_from_path
from glitchygames.pixels import image_from_pixels
from glitchygames.pixels import rgb_triplet_generator
from glitchygames.scenes import Scene
from glitchygames.sprites import MousePointer, BitmappySprite
from glitchygames.ui import SliderSprite, ColorWellSprite, InputDialog, MenuBar, MenuItem

LOG = logging.getLogger('game')
LOG.setLevel(logging.INFO)

# Turn on sprite debugging
BitmappySprite.DEBUG = True


class LoadDialogScene(Scene):
    log = LOG
    NAME = "Load Sprite"
    VERSION = ""

    def __init__(self, previous_scene=None, options=None, groups=pygame.sprite.LayeredDirty()):
        super().__init__(options=options, groups=groups)
        self.previous_scene = previous_scene

        self.load_dialog = InputDialog(
            name='Load Sprite',
            dialog_text='Would you like to load a sprite?',
            confirm_text='Load',
            x=self.screen.get_rect().center[0] // 2,
            y=self.screen.get_rect().center[1] // 2,
            width=self.screen_width // 2,
            height=self.screen_height // 2,
            groups=self.all_sprites
        )

    def setup(self):
        self.load_dialog.cancel_button.callbacks = {'on_left_mouse_button_up_event': self.on_cancel_event}
        self.load_dialog.confirm_button.callbacks = {'on_left_mouse_button_up_event': self.on_confirm_event}

        self.load_dialog.add(self.all_sprites)

    def cleanup(self):
        self.next_scene = self

    def dismiss(self):
        self.previous_scene.next_scene = self.previous_scene
        self.next_scene = self.previous_scene

    def on_cancel_event(self, event, trigger):
        self.log.info(f'Cancel: event: {event}, trigger: {trigger}')
        self.dismiss()

    def on_confirm_event(self, event, trigger):
        self.log.info(f'Load File: event: {event}, trigger: {trigger}')
        self.previous_scene.canvas.on_load_file_event(event, trigger)
        self.dismiss()


class SaveDialogScene(Scene):
    log = LOG
    NAME = "Save Sprite"
    VERSION = ""

    def __init__(self, previous_scene=None, options=None, groups=pygame.sprite.LayeredDirty()):
        super().__init__(options=options, groups=groups)
        self.previous_scene = previous_scene

        self.save_dialog = InputDialog(
            name='Save Sprite',
            dialog_text='Would you like to save your sprite?',
            confirm_text='Save',
            x=self.screen.get_rect().center[0] // 2,
            y=self.screen.get_rect().center[1] // 2,
            width=self.screen_width // 2,
            height=self.screen_height // 2,
            groups=self.all_sprites
        )

    def setup(self):
        self.save_dialog.cancel_button.callbacks = {'on_left_mouse_button_up_event': self.on_cancel_event}
        self.save_dialog.confirm_button.callbacks = {'on_left_mouse_button_up_event': self.on_confirm_event}

        self.save_dialog.add(self.all_sprites)


    def cleanup(self):
        self.next_scene = self

    def dismiss(self):
        self.previous_scene.next_scene = self.previous_scene
        self.next_scene = self.previous_scene

    def on_cancel_event(self, event, trigger):
        self.log.info(f'Cancel: event: {event}, trigger: {trigger}')
        self.dismiss()

    def on_confirm_event(self, event, trigger):
        self.log.info(f'Safe File: event: {event}, trigger: {trigger}')
        self.previous_scene.canvas.on_save_file_event(event, trigger)
        self.dismiss()


class BitmapPixelSprite(BitmappySprite):
    """
    """
    log = LOG
    PIXEL_CACHE = {}

    def __init__(self, x=0, y=0, width=1, height=1, name=None, pixel_number=0, border_thickness=1, groups=pygame.sprite.LayeredDirty()):
        super().__init__(x=x, y=x, width=width, height=height, name=name, groups=groups)
        self.log.debug(f'BITMAP PIXEL SPRITE GROUPS: {groups}')
        self.pixel_number = pixel_number
        self.pixel_width = width
        self.pixel_height = height
        self.border_thickness = border_thickness
        self.width = self.pixel_width
        self.height = self.pixel_height
        self.color = (96, 96, 96)
        self.pixel_color = (0, 0, 0)
        self.x = x
        self.y = y

        self.rect = pygame.draw.rect(self.image, self.color, (self.x, self.y, self.width, self.height), self.border_thickness)

    @property
    def pixel_color(self):
        return self._pixel_color

    @pixel_color.setter
    def pixel_color(self, new_pixel_color):
        self._pixel_color = new_pixel_color
        self.dirty = 1

    def update(self):
        self.log.debug(f'Updating Pixel #: {self.pixel_number} @ {self.x}, {self.y}')
        cached_image = BitmapPixelSprite.PIXEL_CACHE.get(self.pixel_color)

        if not cached_image:
            self.image = pygame.Surface((self.width, self.height))
            self.rect = pygame.draw.rect(self.image, self.pixel_color, (0, 0, self.width, self.height))

            # Store this as an image and blit for a speedup.
            if self.border_thickness:
                pygame.draw.rect(self.image, self.color, (0, 0, self.width, self.height), self.border_thickness)

            BitmapPixelSprite.PIXEL_CACHE[self.pixel_color] = self.image
        else:
            self.image = cached_image


    def on_pixel_update_event(self, event):
        if self.callbacks:
            callback = self.callbacks.get('on_pixel_update_event', None)

            if callback:
                callback(event=event, trigger=self)


    def on_left_mouse_button_down_event(self, event):
        self.dirty = 1
        self.on_pixel_update_event(event)

    # def on_left_mouse_drag_event(self, event, trigger):
    #     # There's not a good way to pass any useful info, so for now, pass None
    #     # since we're not using the event for anything in this class.
    #     self.on_left_mouse_button_down_event(None)

class CanvasSprite(BitmappySprite):
    log = LOG
    WIDTH = 32
    HEIGHT = 32
    DEBUG = False

    def __init__(self, x, y, width, height, name, has_mini_view=True, groups=pygame.sprite.LayeredDirty()):
        super().__init__(x=x, y=y, width=width, height=height, name=name, groups=groups)

        self.character_sprite = False

        self.border_thickness = 0
        self.border_margin = 0
        self.pixels_across = CanvasSprite.WIDTH
        self.pixels_tall = CanvasSprite.HEIGHT
        self.pixels = [(255, 0, 255)] * self.pixels_across * self.pixels_tall
        self.grid_line_width = 0
        self.pixel_boxes = []
        self.pixel_width = 1
        self.pixel_height = 1
        self.mini_view = None
        self.resize_widget = None
        self.active_color = (255, 255, 255)

        print(f'Canvas: {self.rect.x}, {self.rect.y}')

        self.name = 'Bitmap Canvas'

        if self.pixels_across >= self.pixels_tall:
            self.pixel_width = self.width//self.pixels_across - self.border_thickness * 2
            self.pixel_height = self.width//self.pixels_across - self.border_thickness * 2
        else:
            self.pixel_width = self.height//self.pixels_tall - self.border_thickness * 2
            self.pixel_height = self.height//self.pixels_tall - self.border_thickness * 2
        print(f'Pixels Across: {self.pixels_across}')
        print(f'Pixels Tall: {self.pixels_tall}')
        print(f'')

        # Can we change this to groups?
        self.all_sprites = groups

        self.pixel_boxes = [
                BitmapPixelSprite(
                    name=f'pixel {pixel_number}',
                    x=self.rect.x,
                    y=self.rect.y
                )
            for i, pixel_number in enumerate(range(1))
        ]

        for pixel_number, pixel in enumerate(self.pixel_boxes):
            self.log.info(
                f'BRO: Pixel Number: {pixel_number} '
                f'x: {pixel.x} '
                f'y: {pixel.y} '
                f'rect.x: {pixel.rect.x} '
                f'rect.y: {pixel.rect.y}'
            )

        self.all_sprites.add(self)

        # pixel_offset_x = 0
        # pixel_offset_y = 0
        # for pixel_number in range(self.pixels_across * self.pixels_tall):
        #     pixel_x = pixel_offset_x * self.pixel_width
        #     pixel_y = pixel_offset_y * self.pixel_height
        #     self.log.info(f'Pixel box #: {pixel_number}')
        #     pixel_box = BitmapPixelSprite(name=f'pixel {pixel_number}',
        #                                   x=self.rect.x,
        #                                   y=self.rect.y,
        #                                   height=self.pixel_width,
        #                                   width=self.pixel_height, groups=groups)
        #     pixel_box.pixel_color = self.pixels[pixel_number]
        #     pixel_box.rect.x = pixel_x + self.rect.x
        #     pixel_box.rect.y = pixel_y + self.rect.y

        #     # This allows us to update the mini map.
        #     pixel_box.callbacks = {'on_pixel_update_event': self.on_pixel_update_event}

        #     self.pixel_boxes.append(pixel_box)

        #     if (pixel_offset_x + 1) % self.pixels_across == 0:
        #         pixel_offset_x = 0
        #         pixel_offset_y += 1
        #     else:
        #         pixel_offset_x += 1

        self.pixel_boxes = [BitmapPixelSprite(name=f'pixel {i}',
                                              pixel_number=i,
                                              x=0,
                                              y=0,
                                              height=self.pixel_width,
                                              width=self.pixel_height)
                                              for i in range(self.pixels_across * self.pixels_tall)]

        for pixel_box in self.pixel_boxes:
           self.log.info(f'Pixel Box Groups: {pixel_box.groups}')
           self.all_sprites.add(pixel_box)

        for i in range(self.pixels_across * self.pixels_tall):
            self.pixel_boxes[i].pixel_color = self.pixels[i]
            self.pixel_boxes[i].add(self.all_sprites)

            # This allows us to update the mini map.
            self.pixel_boxes[i].callbacks = {'on_pixel_update_event': self.on_pixel_update_event}

            # This draws the map box.
            self.pixel_boxes[i].dirty = 1

        if has_mini_view:
            pixel_width, pixel_height = MiniView.pixels_per_pixel(self.pixels_across, self.pixels_tall)
            self.mini_view = MiniView(pixels=self.pixels,
                                      x=self.screen_width - (self.pixels_across * pixel_width),
                                      y=self.rect.y + self.pixels_tall,
                                      width=self.pixels_across,
                                      height=self.pixels_tall,
                                      groups=groups)
            self.mini_view.pixels = self.pixels
            self.mini_view.rect.x = self.screen_width - self.mini_view.width
            self.mini_view.rect.y = self.rect.y

        self.update_anyway = False

    def on_pixel_update_event(self, event, trigger):
        if self.mini_view:
            self.mini_view.pixels[trigger.pixel_number] = trigger.pixel_color
            self.mini_view.dirty_pixels[trigger.pixel_number] = True
            self.mini_view.on_pixel_update_event(event, trigger)
            self.mini_view.dirty = 1

        self.pixel_boxes[trigger.pixel_number].pixel_color = trigger.pixel_color

        # if self.pixel_boxes[trigger.pixel_number].dirty:
        #     self.pixel_boxes[trigger.pixel_number].update()

        self.dirty = 1

    def update_nested_sprites(self):
        if self.mini_view:
            self.mini_view.dirty = self.dirty

    def update(self):
        x = 0
        y = 0
        self.border_thickness = 0
        self.border_margin = 0
        for i, pixel_box in enumerate(self.pixel_boxes):
            if pixel_box.dirty:
                pixel_x = x * pixel_box.pixel_width
                pixel_y = y * pixel_box.pixel_height

                adjusted_pixel_box_width = pixel_box.pixel_width if x == 0 else pixel_box.pixel_width - 1
                adjusted_pixel_box_height = pixel_box.pixel_height if y == 0 else pixel_box.pixel_height - 1

                pixel_x = self.border_margin + self.border_thickness + (x * adjusted_pixel_box_width) + (x * pixel_box.border_thickness)
                pixel_y = self.border_margin + self.border_thickness + (y * adjusted_pixel_box_height) + (y * pixel_box.border_thickness)

                pixel_box.rect.x = pixel_x + self.rect.x
                pixel_box.rect.y = pixel_y + self.rect.y
                self.image.blit(pixel_box.image, (pixel_box.x, pixel_box.y))

                if self.mini_view:
                    self.mini_view.dirty = 1

            if (x + 1) % self.pixels_across == 0:
                x = 0
                y += 1
            else:
                x += 1

    def on_left_mouse_button_down_event(self, event):
        # Check for a sprite collision against the mouse pointer.
        #
        # First, we need to create a pygame Sprite that represents the tip of the mouse.
        mouse = MousePointer(x=event.pos[0], y=event.pos[1])

        collided_sprites = pygame.sprite.spritecollide(mouse, self.all_sprites, False)

        for sprite in collided_sprites:
            sprite.pixel_color = self.active_color
            sprite.dirty = 1

            if type(sprite) == BitmapPixelSprite:
                self.on_pixel_update_event(event=event, trigger=sprite)
            elif sprite is not self:
                sprite.on_left_mouse_button_down_event(event)

    def on_left_mouse_drag_event(self, event, trigger):
        self.on_left_mouse_button_down_event(event)

    def on_new_file_event(self, event, trigger):
        for i, pixel in enumerate([(255, 0, 255)] * self.pixels_across * self.pixels_tall):
            event = pygame.event.Event(events.GAMEEVENT, {'action':'on_new_file_event',
                                                          'pixel_color': pixel,
                                                          'pixel_number': i})

            # Create a pixel update event for the mini map.
            self.on_pixel_update_event(event=event, trigger=event)

        self.dirty = 1
        # self.update()

    def on_save_file_event(self, event, trigger):
        pixels = []

        for pixel_box in self.pixel_boxes:
            pixels.append(pixel_box.pixel_color)

        # Generate a new bitmappy sprite and tell it to save.
        save_sprite = BitmappySprite(x=0,
                                     y=0,
                                     width=self.pixels_across,
                                     height=self.pixels_tall,
                                     name='Tiley McTile Face')

        save_sprite.image = image_from_pixels(pixels=pixels,
                                              width=save_sprite.width,
                                              height=save_sprite.height)

        save_sprite.save(filename='savefile.cfg')

        self.dirty = 1

        #self.save(filename='screenshot.cfg')


    def on_load_file_event(self, event, trigger):
        load_sprite = BitmappySprite(filename='savefile.cfg',
                                     x=0,
                                     y=0,
                                     width=self.pixels_across,
                                     height=self.pixels_tall)

        pixel_data = pygame.image.tostring(load_sprite.image, 'RGB')

        pixels = pixels_from_data(pixel_data=pixel_data)

        # self.log.info(pixels)

        # Update the canvas' pixels across and tall
        self.pixels_across = load_sprite.width
        self.pixels_tall = load_sprite.height

        # pixels = [pixel_box.pixel_color for pixel_box in self.pixel_boxes]
        # pixels = [(255, 255, 255)] * len(pixels)

        #print(pixels)

        for i, pixel in enumerate(pixels):
            trigger.pixel_number = i
            trigger.pixel_color = pixel

            event = pygame.event.Event(events.GAMEEVENT, {'action':'on_load_file_event',
                                                          'pixel_color': pixel,
                                                          'pixel_number': i})

            # Create a pixel update event for the mini map.
            self.on_pixel_update_event(event=event, trigger=event)

        # for pixel_box in self.pixel_boxes:
        #     pixel_box.dirty = 1
        #     pixel_box.update()

        self.dirty = 1
        # self.update()


class MiniView(CanvasSprite):
    log = LOG

    @staticmethod
    def pixels_per_pixel(pixels_across, pixels_tall):
        pixel_width = 0
        pixel_height = 0

        if pixels_across < 64:
            pixel_width = 64 // pixels_tall
        else:
            pixel_width = 1

        if pixels_tall < 64:
            pixel_height = 64 // pixels_tall
        else:
            pixel_height = 1

        return (pixel_width, pixel_height)

    def __init__(self, x=0, y=0, width=0, height=0, name=None, border_thickness=0, pixels=None, groups=None):
        super().__init__(x=x, y=y, width=width, height=height, name=name, has_mini_view=False, groups=groups)
        self.pixels = pixels
        self.dirty_pixels = [False] * len(self.pixels)

        self.pixel_width, self.pixel_height = self.pixels_per_pixel(self.pixels_across, self.pixels_tall)

        # if self.pixels_across < 64:
        #    self.pixel_width = 64 // self.pixels_tall
        # else:
        #    self.pixel_width = 1

        # if self.pixels_tall < 64:
        #    self.pixel_height = 64 // self.pixels_across
        # else:
        #    self.pixel_height = 1

        self.width = self.pixels_across * self.pixel_width
        self.height = self.pixels_tall * self.pixel_height

        self.border_thickness = 0
        self.border_margin = 0

        self.grid_line_width = 0

        self.image = pygame.Surface((self.width, self.height))
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.rect.width = self.width
        self.rect.height = self.height

        self.color_palette = [(0, 255, 0), (255, 0, 255), (255, 255, 0), (0, 0, 0)]
        self.palette_index = 0
        self.image.fill(self.color_palette[self.palette_index])

        self.dirty_pixels = [True] * len(self.pixels)

    # Hack: Not sure why this is needed
    #
    # This is usually for sub-sprites that need to be updated when
    # their parent changes
    #
    # This defers the update of the mini map down in the scene manager
    #
    # The dirty pixel check here saves us a lot of FPS since it ensures
    # that we aren't updating the mini map every frame
    def update_nested_sprites(self):
        if any(self.dirty_pixels):
            self.dirty = 1
            self.dirty_pixels = [False] * len(self.pixels)

    def update(self):
        x = 0
        y = 0

        for i, pixel in enumerate(self.pixels):
            if pixel == (255, 0, 255):
                pygame.draw.rect(self.image, self.color_palette[self.palette_index], ((x, y), (self.pixel_width, self.pixel_height)))
            else:
                pygame.draw.rect(self.image, pixel, ((x, y), (self.pixel_width, self.pixel_height)))
                    # print(f'Updated pixel {i}')



            if (x + self.pixel_width) % (self.pixels_across * self.pixel_width) == 0:
                x = 0
                y += self.pixel_height
            else:
                x += self.pixel_width

        if any(self.dirty_pixels):
            self.screen.blit(self.image, (self.rect.x, self.rect.y))

    def on_left_mouse_button_up_event(self, event):
        self.palette_index += 1

        if self.palette_index >= len(self.color_palette):
            self.palette_index = 0

        self.log.debug(f'MiniMap Palette {self.palette_index}: {self.color_palette[self.palette_index]}')

        self.image.fill(self.color_palette[self.palette_index])

        self.dirty_pixels = [True] * len(self.pixels)
        self.dirty = 1

    def __str__(self):
        return f'pixels across: {self.pixels_across}, pixels tall: {self.pixels_tall}, width: {self.width}, height: {self.height}, pixel width: {self.pixel_width}, pixel_height: {self.pixel_height}, pixels: {len(self.pixels)}, rect: {self.rect}'


class BitmapEditorScene(Scene):
    log = LOG

    # Set your game name/version here.
    NAME = "Bitmappy"
    VERSION = "1.0"

    def __init__(self, options, groups=pygame.sprite.LayeredDirty()):
        super().__init__(options=options, groups=groups)

        width, height = options.get('size').split('x')
        CanvasSprite.WIDTH = int(width)
        CanvasSprite.HEIGHT = int(height)


        self.menu_bar = MenuBar(
            name='Menu Bar',
            x=0,
            y=0,
            width=self.screen_width,
            height=20, groups=self.all_sprites
        )

        self.menu_icon = MenuItem(name=None,
                                  filename='raspberry.cfg',
                                  x=0,
                                  y=0,
                                  width=16,
                                  height=self.menu_bar.height)
        # # When we load the sprite, we set a name.
        # self.menu_icon.name = None

        self.menu_bar.add_menu_item(menu_item=self.menu_icon,
                                    menu=None)

        self.new_menu_item = MenuItem(
            name='New',
            x=self.menu_icon.rect.topright[0],
            y=self.menu_icon.rect.y,
            width=40,
            height=self.menu_bar.height,
            parent=self,
            groups=self.all_sprites
        )
        self.save_menu_item = MenuItem(
            name='Save',
            x=self.new_menu_item.rect.topright[0],
            y=self.new_menu_item.rect.y,
            width=40,
            height=self.menu_bar.height,
            parent=self,
            groups=self.all_sprites
        )
        self.load_menu_item = MenuItem(
            name='Load',
            x=self.save_menu_item.rect.midright[0],
            y=self.save_menu_item.rect.y,
            width=40,
            height=self.menu_bar.height,
            parent=self,
            groups=self.all_sprites
        )
        self.quit_menu_item = MenuItem(
            name='Quit',
            x=self.load_menu_item.rect.midright[0],
            y=self.load_menu_item.rect.y,
            width=40,
            height=self.menu_bar.height,
            parent=self,
            groups=self.all_sprites
        )

        # self.file_menu = MenuItem(name='File', width=32, height=16, groups=self.all_sprites)
        # self.save_menu_item = MenuItem(name='Save', width=40, height=16, groups=self.all_sprites)
        # self.load_menu_item = MenuItem(name='Load', width=40, height=16, groups=self.all_sprites)
        # self.spacer_menu_item = MenuItem(name='----', width=40, height=16, groups=self.all_sprites)
        # self.quit_menu_item = MenuItem(name='Quit', width=40, height=16, groups=self.all_sprites)

        # self.edit_menu = MenuItem(name='Edit', width=32, height=16, groups=self.all_sprites)

        # Add the menu icon as a root level menu item.
        # self.menu_bar.add_menu_item(menu_item=self.menu_icon, menu=None)
        # self.menu_bar.add_menu_item(menu_item=self.file_menu, menu=None)
        # self.menu_bar.add_menu_item(menu_item=self.edit_menu, menu=None)

        # self.menu_bar.add_menu_item(menu_item=self.save_menu_item, menu=None)
        # self.menu_bar.add_menu_item(menu_item=self.load_menu_item, menu=None)
        # self.menu_bar.add_menu_item(menu_item=self.quit_menu_item, menu=None)
        # self.file_menu.add_menu_item(menu_item=self.save_menu_item, menu=None)
        # self.file_menu.add_menu_item(menu_item=self.load_menu_item, menu=None)
        # self.file_menu.add_menu_item(menu_item=self.spacer_menu_item, menu=None)
        # self.file_menu.add_menu_item(menu_item=self.quit_menu_item, menu=None)

        # We'll use the top left quartile of the screen to draw the canvas.
        # We want a square canvas, so we'll use the height as our input.
        # self.canvas = CanvasSprite(name='Bitmap Canvas', x=0, y=self.menu_bar.rect.bottom + 10, width=int(self.screen_height * 0.75), height=int(self.screen_height * 0.75), groups=self.all_sprites)
        self.canvas = CanvasSprite(
            name='Bitmap Canvas',
            x=0,
            y=32,
            width=int(self.screen_height * 0.75),
            height=int(self.screen_height * 0.75),
            groups=self.all_sprites
        )

        slider_height = 9

        self.red_slider = SliderSprite(
            name='R',
            x=10,
            y=self.screen_height - 70,
            width=256,
            height=slider_height,
            groups=self.all_sprites
        )
        self.red_slider.callbacks = {'on_left_mouse_button_down_event': self.on_slider_event}

        self.green_slider = SliderSprite(
            name='G',
            x=10,
            y=self.screen_height - 50,
            width=256,
            height=slider_height,
            groups=self.all_sprites
        )
        self.green_slider.callbacks = {'on_left_mouse_button_down_event': self.on_slider_event}

        self.blue_slider = SliderSprite(
            name='B',
            x=10,
            y=self.screen_height - 30,
            width=256,
            height=slider_height,
            groups=self.all_sprites
        )
        self.blue_slider.callbacks = {'on_left_mouse_button_down_event': self.on_slider_event}

        self.red_slider.value = 0
        self.blue_slider.value = 0
        self.green_slider.value = 0

        self.color_well = ColorWellSprite(
            name='Colorwell',
            x=self.red_slider.rect.midright[0] + 30,
            y=self.red_slider.rect.y,
            width=64,
            height=64,
            groups=groups
        )

        self.color_well.active_color = (
            self.red_slider.value,
            self.green_slider.value,
            self.blue_slider.value
        )

        self.canvas.active_color = self.color_well.active_color

        self.all_sprites.clear(self.screen, self.background)

        # TODO: Plumb this into the scene manager
        # self.register_game_event('save', self.on_save_event)
        # self.register_game_event('load', self.on_load_event)

        self.load_dialog_scene = LoadDialogScene(options=self.options, previous_scene=self)
        self.save_dialog_scene = SaveDialogScene(options=self.options, previous_scene=self)

        # These are set up in the GameEngine class.
        self.log.info(f'Game Options: {options}')

    def on_menu_item_event(self, event):
        self.log.info(f'Scene got menu item event: {event}')
        if not event.menu.name:
            # This is for the system menu.
            self.log.info('System Menu Clicked')
        else:
            if event.menu.name == 'New':
                self.on_new_file_event(event=event)
            elif event.menu.name == 'Save':
                self.on_save_dialog_event(event)
            elif event.menu_item.name == 'Load':
                self.on_load_dialog_event(event)
            elif event.menu.name == 'Quit':
                self.log.info('User quit from menu item.')
                self.scene_manager.quit()
            else:
                raise Exception(f'Unhandled Menu Item: {event}')
        self.dirty = 1

    def on_new_file_event(self, event):
        self.canvas.on_new_file_event(event=event, trigger=event)
        self.dirty = 1

    def on_load_dialog_event(self, event):
        self.load_dialog_scene.all_sprites.clear(self.load_dialog_scene.screen, self.screenshot)
        self.next_scene = self.load_dialog_scene
        self.dirty = 1

    def on_save_dialog_event(self, event):
        self.save_dialog_scene.all_sprites.clear(self.save_dialog_scene.screen, self.screenshot)
        self.next_scene = self.save_dialog_scene
        self.dirty = 1

    def on_color_well_event(self, event, trigger):
        self.log.info('COLOR WELL EVENT')

    def on_slider_event(self, event, trigger):
        value = trigger.value

        self.log.debug(f'Slider: event: {event}, trigger: {trigger} value: {value}')

        if value < 0:
            value = 0
            trigger.value = 0
        elif value > 255:
            value = 255
            trigger.value = 255

        if trigger.name == 'R':
            self.red_slider.value = value
        elif trigger.name == 'G':
            self.green_slider.value = value
        elif trigger.name == 'B':
            self.blue_slider.value = value

        self.color_well.active_color = (self.red_slider.value, self.green_slider.value, self.blue_slider.value)
        self.canvas.active_color = (self.red_slider.value, self.green_slider.value, self.blue_slider.value)

    def on_right_mouse_button_up_event(self, event):
        # If we're on the edge of an outside pixel, ignore
        # the right click so we don't crash.
        try:
            red, green, blue, alpha = self.screen.get_at(event.pos)
            self.log.info(f'Red: {red}, Green: {green}, Blue: {blue}, Alpha: {alpha}')

            # TODO: Make this a proper type.
            trigger = pygame.event.Event(0, {'name': 'R', 'value': red})
            self.on_slider_event(event=event, trigger=trigger)

            trigger = pygame.event.Event(0, {'name': 'G', 'value': green})
            self.on_slider_event(event=event, trigger=trigger)

            trigger = pygame.event.Event(0, {'name': 'B', 'value': blue})
            self.on_slider_event(event=event, trigger=trigger)
        except IndexError:
            pass

    def on_left_mouse_button_down_event(self, event):
        sprites = self.sprites_at_position(pos=event.pos)

        for sprite in sprites:
           sprite.on_left_mouse_button_down_event(event)

    def on_left_mouse_button_up_event(self, event):
        sprites = self.sprites_at_position(pos=event.pos)

        for sprite in sprites:
           sprite.on_left_mouse_button_up_event(event)

    def on_left_mouse_drag_event(self, event, trigger):
        self.canvas.on_left_mouse_drag_event(event, trigger)

        try:
            sprites = self.sprites_at_position(pos=event.pos)

            for sprite in sprites:
                sprite.on_left_mouse_drag_event(event, trigger)
        except AttributeError:
            pass


    @classmethod
    def args(cls, parser):
        parser.add_argument('-v', '--version',
                           action='store_true',
                           help='print the game version and exit')
        parser.add_argument('-s', '--size',
                           default='32x32')


def main():
    GameEngine(game=BitmapEditorScene).start()


if __name__ == '__main__':
    main()



